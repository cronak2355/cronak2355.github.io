---
layout: post
title: "2025-11-03"
date: 2025-11-04 01:49:05 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-11-03)
>오늘은 Week08의 월요일이다 이번 주차부터 웹 서버 제작에 들어간다.

---

## 오늘 한 일
- 가독성 있는 주석을 위해 Doxygen 주석법 공부
- CSAPP 11.5 공부
- tiny.c 공부

---

## TIL
### Doxygen 주석법
#### 사용하는 이유
정보의 표준화 : 주석에 @param, @return 같은 표준화된 태그를 사용하여 필요한 정보(입력, 출력, 목적 등)가 일관된 형식으로 기록되도록 한다.

자동 문서 생성 : Doxygen 툴이 이 표준화된 주석을 읽어 HTML, PDF 등의 전문적인 기술 문서를 자동으로 생성합니다. 이는 특히 대규모 프로젝트에서 필수적이다.

협업 용이성 : 코드를 처음 보는 사람도 주석 블록만으로 함수나 모듈의 **API(사용 방법)**를 즉시 파악할 수 있어, 개발 팀 간의 소통 비용과 학습 시간을 절감한다.

C언어는 클래스나 메소드가 없으므로 클래스 => 구조체, 메소드 => 함수로 변환하여 이해하면 편하다.

아래 설명은 C언어 기준으로 작성되었다.

#### 기본 주석법

doxygen이 인식하는 주석법은 
```c
/**
 * 주석
 *
 *
 */
```  
이런 식으로 /\*\* 주석 시작시 \*을 두번 써 줘야 한다. 
이 방법 말고도 주석 법은 더 있으나 여기서는 다루지 않는다.

클래스(구조체)에 대한 주석
>@brief 간략한 설명
@details 자세한 설명
@author 저작권자
@date 날짜
@version 버전

예시
```c
/**
 * 
 * @brief 테스트를 위한 구조체이다.
 * @details 16바이트를 가지고 있는 구조체이다.
 * @author cronak
 * @date 2025-11-03
 * @version 0.0.1
 *
 */
 struct Test{
 	char a;
    int b;
    long c;
 }
```

메소드(함수)에 대한 주석
>@brief 간략한 설명
@details 자세한 설명
@param 파라미터
@return 반환
@throws 발생 예외

예시
```c
/**
 * @brief 두 정수를 더하는 함수.
 * @details 주어진 두 정수 $a와 $b를 받아 합을 계산한다. 
 * @param int a 첫 번째 정수.
 * @param int b 두 번째 정수.
 * @return int 두 정수의 합. 계산 성공 시 합을 반환한다.
 * @throws -1 입력 값이 정수 범위 밖이거나 내부 계산 오류가 발생했을 경우
 *
 */
 
int plus(int a, int b) 
{
    int sum = a + b;
  	
    return sum;
}
```


### CSAPP 11.5 Web Servers

---

#### CSAPP 11.5.1

1969년 이후 다양한 형태로 존재해 온 글로벌 IP 인터넷은 웹 서버의 기반이다.

#### 역사적 배경

- **1993년**: Marc Andreesen과 NCSA 동료들이 Mosaic이라는 그래픽 브라우저 출시
  - Linux, Windows, Macintosh 세 가지 주요 플랫폼 지원
- **Mosaic 출시 이후**: 웹이 폭발적으로 성장
  - 웹 사이트 수가 기하급수적으로 증가
- **2010년대**: 전 세계적으로 975,000,000개 이상의 사이트 존재 (출처: Netcraft Web Survey)

#### 웹 클라이언트와 서버

- **웹 클라이언트(Web Client)**: 브라우저
- **웹 서버(Web Server)**: 콘텐츠 제공

---

#### CSAPP 11.5.2

웹 클라이언트와 서버에게 콘텐츠는 **MIME 타입**이 연관된 바이트 시퀀스이다.

**MIME (Multipurpose Internet Mail Extensions)**

![](/assets/img/images/2025-11-03-1.png)


| MIME 타입 | 설명 |
|----------|------|
| text/html | HTML 페이지 |
| text/plain | 포맷되지 않은 텍스트 |
| application/postscript | Postscript 문서 |
| image/gif | GIF 형식의 바이너리 이미지 |
| image/png | PNG 형식의 바이너리 이미지 |
| image/jpeg | JPEG 형식의 바이너리 이미지 |

#### 웹 서버가 콘텐츠를 제공하는 두 가지 방법

**1. 정적 콘텐츠 (Static Content)**
- 디스크 파일을 가져와서 그 내용을 클라이언트에게 반환
- 디스크 파일을 **정적 콘텐츠**라고 함
- 파일을 클라이언트에게 반환하는 프로세스를 **정적 콘텐츠 제공(serving static content)**이라고 함

**2. 동적 콘텐츠 (Dynamic Content)**
- 실행 가능한 파일을 실행하고 그 출력을 클라이언트에게 반환
- 실행 파일이 런타임에 생성하는 출력을 **동적 콘텐츠**라고 함
- 프로그램을 실행하고 그 출력을 클라이언트에게 반환하는 프로세스를 **동적 콘텐츠 제공(serving dynamic content)**이라고 함

#### URL (Universal Resource Locator)

웹 서버가 반환하는 모든 콘텐츠는 서버가 관리하는 파일과 연관되어 있다. 각 파일은 **URL**이라는 고유한 이름을 가진다.

**URL 예시:**
```
http://www.google.com:80/index.html
```

**URL 구성:**
```
http://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&213
```
- 실행 파일 `/cgi-bin/adder` 식별
- 두 개의 인자 문자열: `15000`과 `213`

#### 클라이언트와 서버의 URL 사용 방식

**클라이언트가 사용하는 prefix:**
```
http://www.google.com:80
```
- 어떤 종류의 서버에 접촉할지 결정
- 서버가 어디에 있는지 결정
- 서버가 어떤 포트에서 수신 대기 중인지 결정

**서버가 사용하는 suffix:**
```
/index.html
```
- 파일 시스템에서 파일 찾기
- 요청이 정적 콘텐츠인지 동적 콘텐츠인지 판단

#### URL suffix 해석 규칙

**중요한 이해 사항:**

1. **정적/동적 콘텐츠 판단에 표준 규칙 없음**
   - 각 서버마다 관리하는 파일에 대한 자체 규칙 보유
   - 고전적(구식) 접근법: `cgi-bin` 같은 디렉토리 세트 식별, 모든 실행 파일이 거기에 상주

2. **suffix의 초기 `/`는 Linux 루트 디렉토리를 나타내지 않음**
   - 요청되는 콘텐츠 종류의 홈 디렉토리를 나타냄
   - 예시:
     - 모든 정적 콘텐츠는 `/usr/httpd/html` 디렉토리에 저장
     - 모든 동적 콘텐츠는 `/usr/httpd/cgi-bin` 디렉토리에 저장

3. **최소 URL suffix는 `/` 문자**
   - 모든 서버는 `/index.html` 같은 기본 홈 페이지로 확장
   - 브라우저에 도메인 이름만 입력해도 사이트의 홈 페이지를 가져올 수 있는 이유
   - 브라우저가 URL에 누락된 `/`를 추가하여 서버에 전달
   - 서버가 `/`를 기본 파일 이름으로 확장

---

#### CSAPP 11.5.3

HTTP는 인터넷 연결을 통해 전송되는 텍스트 라인을 기반으로 하므로, Linux `telnet` 프로그램을 사용하여 인터넷의 모든 웹 서버와 트랜잭션을 수행할 수 있다.

#### telnet을 사용한 HTTP 트랜잭션 예시

![](/assets/img/images/2025-11-03-2.png)


```bash
1  linux> telnet www.aol.com 80                        Client: open connection to server
2  Trying 205.188.146.23...                            Telnet: trying to connect to server
3  Connected to aol.com.                                Telnet: connection established
4  Escape character is '^]'.
5  GET /index.html HTTP/1.1                             Client: request line
6  Host: www.aol.com                                    Client: required HTTP/1.1 header
7                                                       Client: empty line terminates headers
8  HTTP/1.0 200 OK                                      Server: response line
9  MIME-Version: 1.0                                    Server: followed by five response headers
10 Date: Mon, 8 Jan 2010 4:59:42 GMT
11 Server: Apache-Coyote/1.1
12 Content-Type: text/html                              Server: expect HTML in the response body
13 Content-Length: 42092                                Server: expect 42,092 bytes in the response body
14                                                       Server: empty line terminates response headers
15 <html>                                                Server: first HTML line in response body
16 ...                                                   Server: 766 lines of HTML not shown
17 </html>                                               Server: last HTML line in response body
18 Connection closed by foreign host.                   Server: closes connection
19 linux>                                                Client: closes connection and terminates
```

#### HTTP Requests (HTTP 요청)

HTTP 요청은 다음으로 구성된다:
1. **요청 라인** (request line) - 라인 5
2. **0개 이상의 요청 헤더** (request headers) - 라인 6
3. **빈 텍스트 라인** (헤더 목록 종료) - 라인 7

**요청 라인 형식:**
```
method URI version
```

**HTTP 메소드:**
- GET, POST, OPTIONS, HEAD, PUT, DELETE, TRACE
- 여기서는 HTTP 요청의 대다수를 차지하는 **GET 메소드**만 다룸

**GET 메소드:**
- 서버에게 URI로 식별되는 콘텐츠를 생성하고 반환하도록 지시

#### Request Headers (요청 헤더)

요청 헤더는 서버에 추가 정보를 제공한다.

**형식:**
```
header-name: header-data
```

**중요한 헤더:**
- **Host 헤더** (라인 6):
  - HTTP/1.1 요청에서 필수
  - HTTP/1.0 요청에서는 선택적
  - 프록시 캐시에서 사용
  - 원본 서버의 도메인 이름 식별
  - 프록시 체인 중간의 프록시가 로컬 캐시된 콘텐츠 복사본 보유 여부 판단

**빈 텍스트 라인 (라인 7):**
- 헤더를 종료하고 서버에게 요청된 HTML 파일 전송 신호

#### HTTP Responses (HTTP 응답)

HTTP 응답은 HTTP 요청과 유사하다.

**구성:**
1. **응답 라인** (response line) - 라인 8
2. **0개 이상의 응답 헤더** (response headers) - 라인 9-13
3. **빈 라인** (헤더 종료) - 라인 14
4. **응답 바디** (response body) - 라인 15-17

**응답 라인 형식:**
```
version status-code status-message
```

- **version**: 응답이 따르는 HTTP 버전
- **status-code**: 요청의 처리 결과를 나타내는 3자리 양의 정수
- **status-message**: 에러 코드의 영어 표현

**주요 HTTP Status Codes:**

![](/assets/img/images/2025-11-03-3.png)



| 상태 코드 | 상태 메시지 | 설명 |
|---------|------------|------|
| 200 | OK | 요청이 오류 없이 처리됨 |
| 301 | Moved permanently | 콘텐츠가 Location 헤더의 호스트 이름으로 이동 |
| 400 | Bad request | 서버가 요청을 이해할 수 없음 |
| 403 | Forbidden | 서버가 요청된 파일에 접근 권한 없음 |
| 404 | Not found | 서버가 요청된 파일을 찾을 수 없음 |
| 501 | Not implemented | 서버가 요청 메소드를 지원하지 않음 |
| 505 | HTTP version not supported | 서버가 요청의 버전을 지원하지 않음 |

#### Response Headers (응답 헤더)

응답에 대한 추가 정보 제공

**가장 중요한 두 헤더:**

1. **Content-Type** (라인 12):
   - 응답 바디 콘텐츠의 MIME 타입을 클라이언트에 알림

2. **Content-Length** (라인 13):
   - 콘텐츠의 바이트 크기 표시

**빈 텍스트 라인** (라인 14):
- 응답 헤더를 종료

**응답 바디**:
- 요청된 콘텐츠 포함

---

#### CSAPP 11.5.4

서버가 클라이언트에게 동적 콘텐츠를 제공하는 방법에 대한 질문들:
- 클라이언트는 어떻게 프로그램 인자를 서버에 전달하는가?
- 서버는 어떻게 이 인자들을 생성하는 자식 프로세스에 전달하는가?
- 서버는 자식이 콘텐츠를 생성하는 데 필요한 다른 정보를 어떻게 전달하는가?
- 자식은 출력을 어디로 보내는가?

이러한 질문들은 **CGI (Common Gateway Interface)**라는 사실상의 표준으로 해결된다.

#### 클라이언트가 프로그램 인자를 서버에 전달하는 방법

GET 요청의 인자는 URI에서 전달된다.

**규칙:**
- `?` 문자가 파일 이름과 인자를 분리
- 각 인자는 `&` 문자로 분리
- 공백은 허용되지 않으며 `%20` 문자열로 표현
- 다른 특수 문자에 대한 유사한 인코딩 존재

**예시:**
```
GET /cgi-bin/adder?15000&213 HTTP/1.1
```

#### 서버가 인자를 자식에게 전달하는 방법
```
GET /cgi-bin/adder?15000&213 HTTP/1.1
```

서버가 이런 요청을 받으면:

1. `fork`를 호출하여 자식 프로세스 생성
2. `execve`를 호출하여 자식의 컨텍스트에서 `/cgi-bin/adder` 프로그램 실행
3. `adder`와 같은 프로그램을 **CGI 프로그램**이라고 함 (CGI 표준 규칙 준수)
4. `execve` 호출 전, 자식 프로세스는 CGI 환경 변수 `QUERY_STRING`을 `15000&213`으로 설정
5. `adder` 프로그램은 런타임에 Linux `getenv` 함수를 사용하여 참조 가능

#### 서버가 자식에게 다른 정보를 전달하는 방법

CGI는 CGI 프로그램이 실행될 때 설정되어 있을 것으로 예상할 수 있는 다양한 환경 변수를 정의한다.

**CGI 환경 변수 예시:**

![](/assets/img/images/2025-11-03-4.png)


| 환경 변수 | 설명 |
|----------|------|
| QUERY_STRING | GET 요청의 프로그램 인자 |
| SERVER_PORT | 부모가 수신 대기 중인 포트 |
| REQUEST_METHOD | GET 또는 POST |
| REMOTE_HOST | 클라이언트의 도메인 이름 |
| REMOTE_ADDR | 클라이언트의 IP 주소 |
| CONTENT_TYPE | POST만 해당: 요청 바디의 MIME 타입 |
| CONTENT_LENGTH | POST만 해당: 요청 바디의 바이트 크기 |

#### 자식이 출력을 보내는 위치

CGI 프로그램은 동적 콘텐츠를 **표준 출력**으로 전송한다.

**프로세스:**
1. 자식 프로세스가 CGI 프로그램을 로드하고 실행하기 전
2. Linux `dup2` 함수를 사용하여 표준 출력을 클라이언트와 연관된 연결 디스크립터로 리다이렉트
3. CGI 프로그램이 표준 출력에 쓰는 모든 것이 클라이언트로 직접 전달됨

**중요 사항:**
- 부모는 자식이 생성하는 콘텐츠의 타입이나 크기를 알지 못함
- 자식이 `Content-Type`과 `Content-Length` 응답 헤더 생성을 담당
- 헤더를 종료하는 빈 라인도 자식이 생성

#### CGI 프로그램 예시 - adder

![](/assets/img/images/2025-11-03-5.png)


```c
#include "csapp.h"

int main(void) {
    char *buf, *p;
    char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];
    int n1=0, n2=0;
    
    /* 두 인자 추출 */
    if ((buf = getenv("QUERY_STRING")) != NULL) {
        p = strchr(buf, '&');
        *p = '\0';
        strcpy(arg1, buf);
        strcpy(arg2, p+1);
        n1 = atoi(arg1);
        n2 = atoi(arg2);
    }
    
    /* 응답 바디 생성 */
    sprintf(content, "QUERY_STRING=%s", buf);
    sprintf(content, "Welcome to add.com: ");
    sprintf(content, "%sTHE Internet addition portal.\r\n<p>", content);
    sprintf(content, "%sThe answer is: %d + %d = %d\r\n<p>",
            content, n1, n2, n1 + n2);
    sprintf(content, "%sThanks for visiting!\r\n", content);
    
    /* HTTP 응답 생성 */
    printf("Connection: close\r\n");
    printf("Content-length: %d\r\n", (int)strlen(content));
    printf("Content-type: text/html\r\n\r\n");
    printf("%s", content);
    fflush(stdout);
    
    exit(0);
}
```

#### 동적 콘텐츠 제공 HTTP 트랜잭션

![](/assets/img/images/2025-11-03-6.png)


```bash
1  linux> telnet kittyhawk.cmcl.cs.cmu.edu 8000         Client: open connection to server
2  Trying 128.2.194.242...
3  Connected to kittyhawk.cmcl.cs.cmu.edu.
4  Escape character is '^]'.
5  GET /cgi-bin/adder?15000&213 HTTP/1.0                Client: request line
6                                                        Client: empty line terminates headers
7  HTTP/1.0 200 OK                                      Server: response line
8  Server: Tiny Web Server                              Server: identify server
9  Content-length: 115                                  Adder: expect 115 bytes in response body
10 Content-type: text/html                              Adder: expect HTML in response body
11                                                       Adder: empty line terminates headers
12 Welcome to add.com: THE Internet addition portal.    Adder: first HTML line
13 <p>The answer is: 15000 + 213 = 15213                Adder: second HTML line in response body
14 <p>Thanks for visiting!                              Adder: third HTML line in response body
15 Connection closed by foreign host.                   Server: closes connection
16 linux>                                                Client: closes connection and terminates
```

---

### 핵심 정리

#### 11.5.1의 핵심
1. **웹의 역사**: 1993년 Mosaic 출시 이후 폭발적 성장
2. **웹 구성 요소**: 클라이언트(브라우저)와 서버

#### 11.5.2의 핵심
1. **MIME 타입**: 콘텐츠의 종류를 식별하는 표준
2. **정적 콘텐츠**: 디스크 파일을 그대로 반환
3. **동적 콘텐츠**: 프로그램 실행 결과를 반환
4. **URL**: 각 파일의 고유 식별자
5. **URL 해석**: 서버마다 자체 규칙 보유

#### 11.5.3의 핵심
1. **HTTP 요청**: 요청 라인 + 헤더 + 빈 라인
2. **HTTP 응답**: 응답 라인 + 헤더 + 빈 라인 + 바디
3. **GET 메소드**: 가장 많이 사용되는 HTTP 메소드
4. **상태 코드**: 200 (성공), 404 (없음), 500대 (서버 오류) 등
5. **텔넷 활용**: HTTP 트랜잭션 디버깅에 유용

#### 11.5.4의 핵심
1. **CGI**: 동적 콘텐츠 생성을 위한 표준 인터페이스
2. **인자 전달**: URI의 쿼리 스트링 (`?`와 `&` 사용)
3. **환경 변수**: `QUERY_STRING` 등으로 정보 전달
4. **표준 출력**: CGI 프로그램의 출력이 클라이언트로 직접 전달
5. **헤더 생성**: CGI 프로그램이 Content-Type과 Content-Length 생성 책임

## 코드 / 실습
tiny.c 기본 세팅
```c
/* $begin tinymain */
/*
 * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the
 *     GET method to serve static and dynamic content.
 *
 * Updated 11/2019 droh
 *   - Fixed sprintf() aliasing issue in serve_static(), and clienterror().
 */
#include "csapp.h"

/**
*	@brief 한 개의 HTTP 트랜잭션을 처리
*	@details 
*	@param fd 클라이언트 소켓 파일 디스크립터
*	@return void(반환값 없음)
*	@throw 발생 예외 없음
*
*/
void doit(int fd);

/**
* @brief 전체 헤더들을 빈줄을 만날때까지 읽어들이기
* @details
* @param rp RIO(버퍼 읽어들이는 구조체) 포인터
* @return void(반환값 없음)
* @throw 발생 예외 없음
* 
*/
void read_requesthdrs(rio_t *rp);

/**
*	@brief URI 구조화하여 분리, 정적/동적 콘텐츠 분류
*	@details 
*	@param uri URI
* @param filename 파일 이름이 저장될 곳
* @param cgiargs ?뒤에 있는 CGI 인자 값들을 저장
*	@return int(반환값 있음)
*	@throw 발생 예외 없음
*
*/
int parse_uri(char *uri, char *filename, char *cgiargs);

/**
*	@brief 정적 파일을 클라이언트에 전송 
*	@details 
*	@param fd 클라이언트 소켓 파일 디스크럽터
* @param filename 전송할 파일 경로
* @param filesize 파일 크기
*	@return void(반환값 없음)
*	@throw 발생 예외 없음
*
*/
void serve_static(int fd, char *filename, int filesize);

/**
*	@brief 파일 확장자를 보고 MIME 타입을 결정한다
*	@details 
*	@param filename 파일 이름
* @param filetype MIME 타입을 저장할 곳
*	@return void(반환값 없음)
*	@throw 발생 예외 없음
*
*/
void get_filetype(char *filename, char *filetype);

/**
*	@brief 동적 파일을 클라이언트에 전송
*	@details 
*	@param fd 클라이언트 소켓 파일 디스크럽터
* @param filename 실행할 CGI 프로그램 경로
* @param cgiargs ?뒤에 있는 CGI 인자 값들을 저장
*	@return void(반환값 없음)
*	@throw 발생 예외 없음
*
*/
void serve_dynamic(int fd, char *filename, char *cgiargs);

/**
 * @brief 클라이언트에게 HTTP 에러 응답을 전송한다
 * @details 
 * @param fd 클라이언트 소켓 파일 디스크럽터
 * @param cause 에러 원인
 * @param errnum 에러 코드
 * @param shortmsg 짧은 메시지
 * @param longmsg 상세 메시지
 * @return void(반환값 없음)
 * @throw 발생 예외 없음
 */
void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg);
/////////////////////////////////////////////////////////////////////////////////////////////////////

/**
 *
 *	@brief 서버 구동, 유효한 서버 인자 값을 받고 서버 유지를 위해 무한 반복 한다.
 *	@details 
 *	@param argc 운영체제에서 입력 받는 인자 개수
 *  @param argv [0]는 프로그램 이름, [1]은 포트번호
 *	@return int(반환값 있음)
 *	@throw 발생 예외 없음
 *
 */
int main(int argc, char **argv)
```

main 함수
```c
int main(int argc, char **argv)
{
  int listenfd, connfd;
  char hostname[MAXLINE], port[MAXLINE];
  socklen_t clientlen;
  struct sockaddr_storage clientaddr;

  if (argc != 2) // 서버 인자 크기는 프로그램 이름 + 포트번호로 무조건 2여야 한다.
  {
    fprintf(stderr, "usage: %s <port>\n", argv[0]); // 문제점 알아내기 위하여 출력
    exit(1);
  }

  listenfd = Open_listenfd(argv[1]); // 포트에서 연결 요청을 기다리기 위한 listening socket 생성
  while (1) // 서버는 상시 가동상태여야 함
  {
    clientlen = sizeof(clientaddr); // 클라이언트 주소 구조체 크기 설정 (Accept 함수에 필요)
    connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen); // 클라이언트 연결 수락하고 통신용 소켓 생성
    Getnameinfo((SA *)&clientaddr, clientlen, hostname, MAXLINE, port, MAXLINE, 0); // 클라이언트 IP와 포트를 문자열로 변환 (로깅용)
    printf("Accepted connection from (%s, %s)\n", hostname, port);
    doit(connfd);  // 클라이언트 HTTP 요청 처리
    Close(connfd); // 연결 소켓 닫기
  }
}
```

doit 함수
```c
void doit(int fd)
{
  int is_static;
  struct stat sbuf;
  char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
  char filename[MAXLINE], cgiargs[MAXLINE];
  rio_t rio;

  /*Read request line and headers*/
  /* 클라이언트의 HTTP 요청을 수신하여, 요청 메서드와 헤더 정보를 파싱한다 */
  Rio_readinitb(&rio, fd); // Rio 버퍼 초기화                                   
  Rio_readlineb(&rio, buf, MAXLINE); // 버퍼 값 읽기
  printf("Request headers:\n");
  printf("%s", buf);
  sscanf(buf, "%s%s%s", method, uri, version);
  if (strcasecmp(method, "GET")) //메서드가 GET이 여야한다.
  {
    clienterror(fd, method, "501", "Not implemented", "Tiny does not implement this method");
    return;
  }
  read_requesthdrs(&rio); //버퍼 전체 읽기

  /*Parse URI from GET request */
  /*GET 요청으로부터 URI를 얻기 */
  is_static = parse_uri(uri, filename, cgiargs); // 동적, 정적 서버 구분
  if (stat(filename, &sbuf) < 0) //요청된 파일이 유효한지 확인
  {
    clienterror(fd, filename, "404", "Notfound", "Tiny couldn’t find this file");
    return;
  }

  if (is_static)
  { /*Serve static content*/
    /*정적 콘텐츠*/
    if (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR & sbuf.st_mode)) //파일이 일반 파일인지, 권한이 있는지 확인
    {
      clienterror(fd, filename, "403", "Forbidden", "Tiny couldn’t read the file");
      return;
    }
    serve_static(fd, filename, sbuf.st_size);
  }
  else 
  { /*Serve dynamic content*/
    /*동적 콘텐츠*/
    if (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR & sbuf.st_mode)) //파일이 일반 파일인지, 권한이 있는지 확인
    {
      clienterror(fd, filename, "403", "Forbidden", "Tiny  couldn’t run the CGI program");
      return;
    }
    serve_dynamic(fd, filename, cgiargs);
  }
}          
```

clienterror 함수
```c
void clienterror(int fd, char *cause, char *errnum, char *shortmsg, char *longmsg) {
    char buf[MAXLINE], body[MAXBUF];

    // Build the HTTP response body
    // HTTP 응답 본문 생성 시작(에러메시지)
    sprintf(body, "<html><title>Tiny Error</title>");
    sprintf(body + strlen(body), "<body bgcolor=\"ffffff\">\r\n");
    sprintf(body + strlen(body), "%s: %s\r\n", errnum, shortmsg);
    sprintf(body + strlen(body), "<p>%s: %s\r\n", longmsg, cause);
    sprintf(body + strlen(body), "<hr><em>The Tiny Web server</em>\r\n");

    // Print the HTTP response
    // HTTP 응답 전송
    sprintf(buf, "HTTP/1.0 %s %s\r\n", errnum, shortmsg);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-type: text/html\r\n");
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-length: %lu\r\n\r\n", strlen(body));
    Rio_writen(fd, buf, strlen(buf));
    Rio_writen(fd, body, strlen(body));
}
```

read_requesthdrs 함수
```c
/*
 * read_requesthdrs - read HTTP request headers
 */
void read_requesthdrs(rio_t *rp)
{
  char buf[MAXLINE];

  Rio_readlineb(rp, buf, MAXLINE);
  printf("%s", buf);
  while (strcmp(buf, "\r\n")) //헤더들 전체를 읽기 위해
  {
    Rio_readlineb(rp, buf, MAXLINE);
    printf("%s", buf);
  }
  return;
}
```

parse_uri 함수
```c
int parse_uri(char *uri, char *filename, char *cgiargs)
{
  char *ptr;

  if (!strstr(uri, "cgi-bin")) // cgi-bin 문자열이 포함되어 있지 않은 경우 정적 콘텐츠
  { /* Static content */
    strcpy(cgiargs, "");
    strcpy(filename, ".");
    strcat(filename, uri);
    if (uri[strlen(uri) - 1] == '/') // URI가 '/'로 끝난다면 (예: http://host/) 디렉토리 요청으로 간주
      strcat(filename, "home.html");
    return 1; //정적 콘텐츠임을 알림
  }
  else
  { /* Dynamic content */
    ptr = index(uri, '?');
    if (ptr)
    {
      strcpy(cgiargs, ptr + 1);
      *ptr = '\0';
    }
    else
      strcpy(cgiargs, "");
    strcpy(filename, ".");
    strcat(filename, uri);
    return 0; //동적 콘텐츠임을 알림
  }
}
```

serve_static 함수
```c
void serve_static(int fd, char *filename, int filesize) {
    int srcfd;
    char *srcp, filetype[MAXLINE], buf[MAXBUF];

    // Send response headers to client (클라이언트에게 응답 헤더 전송)
    get_filetype(filename, filetype);  // Determine file type (파일 타입 결정) (e.g., text/html)
    sprintf(buf, "HTTP/1.0 200 OK\r\n");

    sprintf(buf + strlen(buf), "Server: Tiny Web Server\r\n");
    sprintf(buf + strlen(buf), "Content-length: %d\r\n", filesize);
    sprintf(buf + strlen(buf), "Content-type: %s\r\n\r\n", filetype);
    
    Rio_writen(fd, buf, strlen(buf));  // Send headers (헤더 전송) (클라이언트 소켓에 버퍼 내용 쓰기)

    // Send response body to client (클라이언트에게 응답 본문 전송)
    srcfd = Open(filename, O_RDONLY, 0);  // Open the file (파일 열기) (읽기 전용으로 요청 파일 열고 디스크립터 얻기)
    
    // Memory-map the file (파일을 메모리 맵핑) (파일 내용을 메모리 주소 공간에 매핑)
    srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0); 
    
    Close(srcfd);  // File descriptor no longer needed (파일 디스크립터 닫기) (메모리 맵핑 후 원본 파일 디스크립터 닫기)
    
    Rio_writen(fd, srcp, filesize);  // Send file content (파일 내용 전송) (메모리에 맵핑된 파일 내용을 클라이언트 소켓에 쓰기)
    
    Munmap(srcp, filesize);  // Unmap the file (파일 매핑 해제) (메모리 맵핑 해제 및 자원 반환)
}
```

serve_dynamic 함수
```c
void serve_dynamic(int fd, char *filename, char *cgiargs) {
    char buf[MAXLINE], *emptylist[] = { NULL };

    // Return first part of HTTP response
    // HTTP의 응답 헤더 전송
    sprintf(buf, "HTTP/1.0 200 OK\r\n");
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Server: Tiny Web Server\r\n");
    Rio_writen(fd, buf, strlen(buf));

    if (Fork() == 0) {  // Child process(자식 프로세스)
        // Real server would set all CGI vars here (실제 서버라면 모든 CGI 변수를 설정해야 함)
        setenv("QUERY_STRING", cgiargs, 1);
        dup2(fd, STDOUT_FILENO);  // Redirect stdout to client (표준 출력(1)을 클라이언트 소켓(fd)으로 복제하여 리디렉션)
        Execve(filename, emptylist, environ);  // Run CGI program (CGI 프로그램 실행)
    }
    Wait(NULL);  // Parent waits for child to terminate (부모는 자식이 종료될 때까지 블로킹하며 대기)
}
```

get_filetype 함수
```c
void get_filetype(char *filename, char *filetype) {

	/* 서식지정자에 따라 파일 타입 정하기*/
    if (strstr(filename, ".html"))
        strcpy(filetype, "text/html");
    else if (strstr(filename, ".gif"))
        strcpy(filetype, "image/gif");
    else if (strstr(filename, ".png"))
        strcpy(filetype, "image/png");
    else if (strstr(filename, ".jpg"))
        strcpy(filetype, "image/jpeg");
    else
        strcpy(filetype, "text/plain"); // 정의된 확장자가 아니면 기본값(text/plain)을 설정
}
```



