---
layout: post
title: "2025-09-15"
date: 2025-09-16 02:49:38 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
현재 작성일자는 9월 16일이지만 9월 15일자 내용을 적는다. 깜빡했다; 
어찌되었든 오늘은 백준 문제 풀기를 하였다. 이번에는 2630, 1629, 10828, 10773, 9012, 17608, 18258, 2164번 문제들을 풀며 느낀 점을 간단히 적어보고자 한다. 아래 모든 내용은 Python 기준으로 작성되었다.

어제부터 이어진 밤샘 코딩으로 몸이 상당히 지쳐있는 상태였지만, 알고리즘 학습에 대한 열정만은 식을 줄 몰랐다. 레드불을 마시며 눈을 비비는 횟수가 늘어갔지만 포기할 수는 없었다.

2630번 - 색종이 만들기 (실버 2)
2630번 문제에서는 분할 정복의 기초를 배웠다. 재귀 함수를 이용해 문제를 작은 단위로 나누어 해결하는 방식이 정말 신선했다.처음에는 막막했지만 재귀의 논리적 흐름을 따라가려고 노력했다. 4등분으로 나누어 각각을 확인하는 부분에서 인덱스 계산을 여러 번 실수했지만, 천천히 종이에 그려가며 해결했다. 분할 정복이 이렇게 직관적일 줄은 몰랐다.

1629번 - 곱셈 (실버 1)
1629번 문제는 거듭제곱을 빠르게 계산하는 문제였는데,처음에는 단순하게 반복문으로 접근했다가 시간 초과를 당했다. 분할 정복을 이용한 거듭제곱 알고리즘을 배우게 되었는데, a^n을 계산할 때 n이 홀수면 a * a^(n-1), 짝수면 (a^(n/2))^2로 나누어 계산하는 방식이 정말 효율적이라고 느꼈다. 파이썬에서는 pow(a, b, c)라는 내장 함수가 있어서 거듭제곱의 나머지를 바로 구할 수 있다는 것을 알았지만, 직접 재귀로 구현해보는 것도 의미가 있었다. 모듈러 연산의 성질도 함께 배웠는데, (a*b) % c = ((a%c) * (b%c)) % c라는 공식이 오버플로우를 방지하는데 얼마나 중요한지 깨달았다.

10828번 - 스택 (실버 4)
10828번 문제에서는 드디어 자료구조의 세계에 발을 들였다. 전에 배운적이 있어 스택의 LIFO(Last In, First Out) 개념은 비교적 쉽게 이해할 수 있었다. 파이썬에서는 리스트를 스택처럼 사용할 수 있다는 것이 정말 편했다. append로 push하고 pop으로 빼고, len으로 크기를 확인하는 방식이 직관적이었다. 다만 빈 리스트에서 pop을 호출할 때 IndexError가 발생할 수 있어서 예외 처리하는 부분을 놓쳐서 런타임 에러를 몇 번 받았다. 개념이 부족하면 이런 예외 상황을 놓치기 쉽다는 것을 배웠다.

10773번 - 제로 (실버 4)
10773번 문제는 스택의 활용 문제였다. 집중이 잘 되지 않았지만, 0이 나오면 직전 수를 지운다는 조건이 스택과 완벽하게 맞아떨어진다는 것을 깨달았다. 파이썬 리스트로 구현하니 정말 간단했는데, 숫자가 0이면 pop(), 아니면 append()하는 방식으로 해결했다. 구현 자체는 어렵지 않았지만, 스택이 비어있을 때 pop을 하려는 경우는 없는지 다시 한번 확인하는 습관을 기르게 되었다. 자료구조를 적절히 선택하는 것이 얼마나 중요한지 느꼈다.

9012번 - 괄호 (실버 4)
9012번 문제에서는 스택을 이용한 괄호 검사를 배웠다. 이 문제는 상당히 흥미로웠다. '('가 나오면 스택에 append하고 ')'가 나오면 pop하는 방식으로, 최종적으로 스택이 비어있으면 올바른 괄호 문자열이라는 논리가 명쾌했다. 파이썬에서는 스택이 비어있는지 확인할 때 not stack 이라는 간단한 표현을 쓸 수 있어서 편했다. 다만 ')'가 나왔는데 스택이 비어있는 경우를 처리하는 부분에서 실수했는데, 이런 상황을 놓치지 않도록 더 신중해져야겠다고 느꼈다.

17608번 - 막대기 (브론즈 2)
17608번 문제는 비교적 간단한 구현 문제였다, 오른쪽에서부터 막대기를 보면서 현재까지의 최댓값보다 큰 막대기만 보인다는 아이디어를 구현했다. 단순해 보이는 문제지만 역순으로 접근한다는 발상의 전환이 필요했고, 피로한 상태에서도 이런 사고력을 유지하는 것이 중요하다고 느꼈다.

18258번 - 큐 2 (실버 4)
18258번 문제에서는 큐 자료구조를 배웠다. FIFO(First In, First Out) 개념을 이해하려고 노력했다. 파이썬에서는 collections 모듈의 deque를 사용했는데, appendleft와 popleft를 통해 양쪽 끝에서 효율적으로 원소를 추가하고 제거할 수 있다는 점이 신기했다. 일반 리스트로 큐를 구현하면 pop(0)이 O(n)이라서 비효율적이지만, deque를 쓰면 O(1)에 해결된다는 것을 배웠다. 피로 상태에서는 이런 기본적인 효율성을 놓치기 쉽다는 것을 명심해야겠다.

2164번 - 카드2 (실버 4)
2164번 문제는 큐의 활용 문제로 마무리했다. 카드를 버리고 맨 아래로 옮기는 과정이 큐의 동작과 정확히 일치한다는 것을 깨달았다. collections.deque를 사용해서 popleft()로 카드를 버리고, append(popleft())로 맨 위 카드를 맨 아래로 옮기는 과정을 구현했다. 구현 자체는 어렵지 않았지만, 반복문의 종료 조건을 설정하는 부분에서 조금 헷갈렸다. 하지만 큐의 길이가 1이 될 때까지 반복한다는 명확한 조건이 있어서 무사히 해결할 수 있었다.

이렇게 밤을 새며 진행한 알고리즘 학습이 끝났다. 피로감이 몰려오지만 동시에 성취감도 느껴진다. 이분 탐색, 분할 정복, 스택, 큐 등 하루에 이렇게 많은 것을 배울 줄은 몰랐다. 밤샘의 부작용으로 실수도 많이 했지만, 그만큼 더 신중해지는 계기가 되었다. 앞으로는 충분한 휴식을 취하면서도 꾸준히 학습해 나가야겠다. 건강관리와 학습의 균형을 맞추는 것도 프로그래머의 중요한 덕목이라는 것을 깨달았다.
나의 일을 하자
-마침-


