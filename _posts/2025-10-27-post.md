---
layout: post
title: "2025-10-27"
date: 2025-10-28 02:08:35 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-10-27)
>오늘은 Week07의 월요일이다 extend_heap, fint_fit, place, mm_malloc을 구현하였다.

---

## 오늘 한 일
- malloc lab의 extend_heap, fint_fit, place, mm_malloc을 구현하였다.


---

## TIL
### **Extend_heap**
크기가 8바이트 배수인지 체크 후 mem_sbrk 호출하여 힙을 확장해준다. 
그 후 Header와 Footer을 Free로 설정해주고 Epilogue로 새로운 끝을 표시해준다.
그 후 새로운 블록의 bp를 반환한다. 

### **fint_fit**
bp에 시작 위치를 받은 후 다음 블록이 없을 때까지 반복문을 돌린다. 
반복문 안에서 다음 블록으로 이동하면서 Free이면서 크기가 충분한 블록을 체크하고 반환한다. 
못 찾았으면 NULL 반환한다.

### **place**
두 가지 조건이 있는데 Free 블록과 원하는 크기가 똑같거나 원하는 크기가 작거나다.
만약 똑같은 경우라면 그래도 header와 footer에 할당해주면 된다.
원하는 크기가 Free 블록보다 작을 경우 필요한 만큼 할당 해준 후 할당 해준 부분은 Allocated 할당 받지 못한 부분은 free로 쪼갠다.

### **mm_malloc**

정렬된 크기 계산
find_fit 호출
찾았으면 place 호출
못 찾았으면 extend_heap 호출 후 place
bp 반환

우선 size 체크하여 0일 경우 NULL로 반환한다. 0이 아닐 경우 계산 요청 된 size를 실제 힙에 할당할 수 있도록 조정된 크기(asize)로 계산한다. 

asize는 블록의 header와 fooater를 더한다. 
8바이트 정렬을 보장하도록 ALIGN(8의 배수로 정렬하는 매크로)를 사용하여최종 크기를 8의 배수로 만든다.

8바이트 배수로 조정된 asize를 인수로 하여 find_fit 함수를 호출한다.
블록들을 순회하며 asize를 수용할 수 있는 블록을 찾는다.

찾았다면 place 호출 한 후 
find_fit를 통해 적합한 블록을 찾을 경우 place(bp, asize)를 호출하여 해당 가용 블록에 메모리를 할당한다.
만약 남는 공간이 충분하다면 분할하여 새로운 가용 블록을 만든다.

적합한 블록을 찾지 못한 경우 extend_heap을 통해 힙을 확장하고 
새로운 가용 블록을 확보한다.

확장된 새 블록의 bp를 얻어 place(bp, asize)를 호출하여 메모리를 할당한다.
bp 할당 과정이 성공적으로 완료되면, 최종적으로 할당된 블록의 bp를 반환하다. 
할당 또는 확장 실패 시에는 NULL을 반환합니다.

---

## 코드 / 실습
Extend_heap
```c
static void *extend_heap(size_t words) {
    char *bp;
    size_t size;

    if(words % 2 == 1) //홀수면 
    {
        words += 1; //짝수로 맞춰주기
    }
    size = words * WSIZE;  //words의 4바이트 배수의 크기를 넣음
    if ((bp = mem_sbrk(size)) == (void *)-1) {
        return NULL;  // 힙 확장 실패 시 NULL 반환
    }
    PUT(HDRP(bp), PACK(size, 0)); //현재 header의 주소에 크기와 할당 여부를 넣음
    PUT(FTRP(bp), PACK(size, 0)); //현재 footer의 주소에 크기와 할당 여부를 넣음
    PUT(HDRP(NEXT_BLKP(bp)), PACK(0, 1)); //다음 블록의 헤더의 주소에 크기와할당 여부를 넣음

    return bp;
}
```
fint_fit
```c
static void *find_fit(size_t asize) {
    char *bp = heap_listp;

    while(GET_SIZE(HDRP(bp)) > 0) { //다음 블록이 있는지 없는지 판별해야함
        if(GET_SIZE(HDRP(bp)) >= asize && GET_ALLOC(HDRP(bp)) == 0) { //블록이 사이즈가 충분하고 free일 경우 리턴
            return bp; 
        }
        bp = NEXT_BLKP(bp); //찾기 못했을 경우 다음 블록으로
    }
    return NULL;
}
```
place
```c
static void place(char *bp, size_t asize) {

    size_t before_size = GET_SIZE(HDRP(bp));

    if(GET_SIZE(HDRP(bp)) == asize) { //Free 블록과 필요한 크기가 똑같을 경우
        PUT(HDRP(bp), PACK(asize, 1)); //전체 할당
        PUT(FTRP(bp), PACK(asize, 1)); //전체 할당
    }
    else if(GET_SIZE(HDRP(bp)) > asize) { //Free 블록이 필요한 크기보다 클 경우
        PUT(HDRP(bp), PACK(asize, 1)); //필요한 만큼 할당
        PUT(FTRP(bp), PACK(asize, 1)); //필요한 만큼 할당
        PUT(HDRP(NEXT_BLKP(bp)), PACK(before_size - asize, 0)); //나머지는 allocated
        PUT(FTRP(NEXT_BLKP(bp)), PACK(before_size - asize, 0)); //나머지는 allocated
    }
}
```
mm_malloc
```c
void *mm_malloc(size_t size)
{
    // size 0 체크
    // 크기 계산
    // find_fit으로 찾기
    // 찾았으면? place
    // 못 찾았으면? extend_heap
    // 반환


    size_t asize;      // 조정된 블록 크기 (헤더/푸터/정렬 포함)
    size_t extendsize; // 힙 확장 시 요청할 크기
    char *bp;          // 블록 포인터 (페이로드 시작 주소)

    
    if (size == 0) { // 요청 크기가 0이면 NULL 반환
        return NULL;
    }

    
    if (size <= DSIZE) { // 요청 크기를 헤더/푸터 및 8바이트 정렬을 포함한 asize로 조정
        asize = 2 * DSIZE;  // 요청이 8B 이하: 최소 블록 크기인 16B (DSIZE*2)로 설정
    } else {
        asize = ALIGN(size + DSIZE); // (size + DSIZE)는 페이로드 + 헤더/푸터 오버헤드를 더한 크기, ALIGN(size + DSIZE)는 이 크기를 8의 배수로 올림 (8바이트 정렬 보장)
    }

    
    if ((bp = find_fit(asize)) != NULL) { // 가용 리스트에서 적합한 블록 찾기
        place(bp, asize); // 찾았으면 할당하고 분할 (place)
        return bp; // bp는 이미 payload 시작 주소를 가리킴 (HDRP(bp) + WSIZE)
    }

    
    extendsize = MAX(asize, CHUNKSIZE); // 적합한 블록을 찾지 못했으면 힙 확장 (extend_heap)
    
    
    if ((bp = extend_heap(extendsize / WSIZE)) == NULL) {  // extend_heap은 워드 단위 크기를 받으므로, 바이트 크기를 WSIZE로 나눔
        return NULL; // 확장 실패
    }

    place(bp, asize); // 확장된 새 블록에 할당하고 포인터 반환
    return bp;
}
```

