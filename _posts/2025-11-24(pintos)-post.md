---
layout: post
title: "2025-11-24(pintos)"
date: 2025-11-25 00:36:45 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---

# Today's Log(2025-11-24)
>오늘은 Week11의 월요일이다. 이번 주차부터 pintos 프로젝트에 들어간다.

---

# 오늘 한 일
- argument passing 개념 공부
- argument passing 구현


# TIL
## Argument Passing - 문자열 파싱 원리

User Program을 실행할 때 프로그램 이름과 인자들을 어떻게 전달할까? 이것이 Argument Passing의 핵심이다.

---

### 1. 문제 상황

#### 현재 Pintos의 문제
```
사용자 입력: "echo hello world"
현재 상태: 전체 문자열을 파일 이름으로 인식
필요한 것: "echo", "hello", "world"로 분리
```

프로그램을 실행하려면:
- 프로그램 이름: "echo"만 필요
- 나머지는 인자로 전달

---

### 2. 파싱(Parsing)이란?

#### 정의
> "하나의 긴 문자열을 여러 개의 작은 조각으로 나누는 것"
```
입력: "echo hello world"
     ↓ 파싱
출력: ["echo", "hello", "world"]
```

#### 기준
공백(" ")을 기준으로 문자열을 나눈다.

---

### 3. 원본 보호의 필요성

#### 문제 상황
문자열 파싱 함수는 **원본 문자열을 수정**한다.
```
원본: "echo hello world"
     ↓ 파싱 후
변경: "echo\0hello\0world"
```

`\0`은 문자열 끝을 나타내는 NULL 문자이다.

#### 왜 문제인가?
```
원본이 필요한 곳:
1. 파일 열기 (filesys_open)
2. 디버깅 출력
3. 에러 메시지

원본이 망가지면 → 제대로 동작하지 않음
```

#### 해결 방법
**복사본을 만들어서 파싱한다.**
```
원본: "echo hello world" (보존)
복사본: "echo hello world" (파싱용)
     ↓
복사본만 수정됨
```

---

### 4. 복사본 만들기

#### 필요한 것
- 문자 배열 (문자 여러 개를 담을 공간)
- 복사 함수
---

### 5. 토큰화(Tokenization)

#### 개념
복사본을 공백 기준으로 나누는 과정
```
입력: "echo hello world"
     ↓
1회: "echo" 추출
2회: "hello" 추출  
3회: "world" 추출
4회: NULL (끝)
```

#### C 라이브러리 함수
`strtok_r()` 함수 사용
- 재진입 가능(reentrant)
- 멀티스레드 환경에서 안전
- 원본을 수정함 (그래서 복사본 필요!)

---

### 6. 토큰 저장

#### 왜 저장하나?
```
지금 당장은: 프로그램 이름만 필요
나중에는: 모든 인자를 스택에 배치
```

#### 저장 방법
**배열 사용**
- 각 토큰의 포인터를 배열에 저장
- 개수를 세면서 저장 (argc)
```
argv[0] = "echo" 주소
argv[1] = "hello" 주소
argv[2] = "world" 주소
argc = 3
```

---

### 7. 전체 과정
```
입력: "echo hello world"
    ↓
Step 1: 복사본 생성
    원본: "echo hello world" (보존)
    복사본: "echo hello world"
    ↓
Step 2: 복사본 파싱
    복사본: "echo\0hello\0world"
    ↓
Step 3: 토큰 저장
    argv[0] = "echo"
    argv[1] = "hello"
    argv[2] = "world"
    argc = 3
    ↓
Step 4: 파일 열기
    filesys_open(argv[0])  // "echo"만 사용
    ↓
Step 5: 스택에 인자 배치 (다음 단계)
```

---

### 8. 핵심 원리

#### 1) 원본은 보호한다
```
원본 → 복사본 → 파싱
```
항상 복사본을 수정하고, 원본은 그대로 둔다.

#### 2) 저장하면서 파싱한다
```
파싱만 하면: 정보 손실
저장하면서: 나중에 사용 가능
```

#### 3) 첫 번째 토큰의 특별함
```
첫 번째 토큰 = 프로그램 이름
→ 파일을 열 때 사용
→ argv[0]에도 저장
```

#### 4) NULL 종료
```
토큰이 더 이상 없으면 NULL 반환
→ 반복 종료 조건
```

---

### 9. 주의사항

#### 순서가 중요하다
```
잘못된 순서:
1. 원본으로 파일 열기 (실패)
2. 원본 파싱 (망가짐)

올바른 순서:
1. 복사본 생성
2. 복사본 파싱 & 저장
3. 첫 번째 토큰으로 파일 열기
```

#### 배열 크기
```
너무 작으면: 인자가 많을 때 문제
적절한 크기: 64개 정도면 충분
```

#### 문자열 포인터 타입
```
토큰은 문자열 → char*
배열은 포인터 배열 → char* 타입의 배열
```

---

### 10. 다음 단계

파싱이 끝나면:
- argv 배열: 모든 인자의 주소
- argc: 인자 개수
- 프로그램 파일: 열림

**다음에 할 일:**
스택에 이 정보들을 배치하기
- 문자열 데이터
- 포인터 배열
- argc, argv, return address

---



# 코드 / 실습
```c
```
