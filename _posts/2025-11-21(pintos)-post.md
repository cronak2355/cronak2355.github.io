---
layout: post
title: "2025-11-21(pintos)"
date: 2025-11-21 23:50:33 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---

# Today's Log(2025-11-21)
>오늘은 Week11의 금요일이다. 이번 주차부터 pintos 프로젝트에 들어간다.

---

# 오늘 한 일
- argument passing 개념 공부


# TIL
## User Mode, Kernel Mode
제한된 권한
┌─────────────────────────┐
│   User Mode (Ring 3)                       
│   - 사용자 프로그램     					  
│   - 제한된 명령어                          
└─────────────────────────┘
			**↕ System Call**
            
 완전한 권한          
┌─────────────────────────┐
│  Kernel Mode (Ring 0)     
│   - 운영체제 코드       
│   - 모든 명령어 가능    
│   - 하드웨어 직접 접근  
└─────────────────────────┘

구분 | User Mode | Kernel Mode
| :---: | :---: | :---: |
권한 |제한적 |완전
메모리 접근 | User 메모리만 | 모든 메모리
명령어 | 일반 명령어 | 특권 명령어 포함
크래시 시 | 프로세스만 종료 | 시스템 전체 종료
```c
// User mode에서 실행
int main() {
    write(1, "hello", 5);  // ← System call 필요!
}

// Kernel mode로 전환
void syscall_handler() {
    // 여기서 실제 write 수행
}
```
### 설명
User mode는 우리가 프로그램을 실사용할때 그 프로그램들이 존재하는 모드다.
이곳에서 프로그램이 작동하는 것이다.

Kernel mode는 막강한 권한을 가지면서 연산을 하는 곳이다.
온갖 복잡한 작업들(메모리 할당 등)들이나 하드웨어 접근은 여기서 진행되며 OS 또한 여기서 존재한다.
일반적인 산술연산, 함수 호출 같은 건 유저모드에서도 똑같이 할 수 있지만
Kernel mode가 진짜 차별화되는 건 **특권 명령어(privileged instruction)**를 사용할 수 있다는 것이다.

예:

하드웨어 직접 제어 (in/out 명령어)
페이지 테이블 베이스 레지스터(CR3) 변경
인터럽트 활성화/비활성화 (cli/sti)
halt 같은 시스템 멈추는 명령어
→ 유저모드에서 쓸 경우 General Protection Fault 오류가 생긴다.

### 작동 방식

유저 모드에서 프로그램이 유저 모드가 CPU 레지스터에다가 시스템 콜과 파일 디스크럽터 번호, 레지스터 주소 같은 것들을 준비하고 syscall를 통해서 커널 모드로 진입한다.

 ↓

커널 모드로 진입하면 커널에서 실제 연산을 수행하고 
그걸 유저 버퍼에다가 기록한다. 

 ↓
 
허나 여기서 알아야 할 것은 지금 기록할려는 것이 유효한 값인지 검사해야한다는 것이다.
그렇지 않을 경우 유저 버퍼의 위치를 못 찾고 커널이 뻗어버릴 수 있다.

 ↓
 
그 후 여러 명령어들을 거치면서 유저 모드로 돌아간다.
유저 모드는 유저 버퍼에는 접근할 수 있기에 유저 버퍼를 보고 연산된 출력 값을 우리한테 보여준다.

## Register vs Memory

### 1. 비교

| 항목              | Register (레지스터)                  | Memory (메모리, DRAM) 
|-|-|-|
| 위치              | CPU die 안에 직접 박혀있음           | 메인보드에 수십 cm 떨어져 있음         |
| 속도              | 1 사이클 이하 (수십 GHz급)           | 50~300+ 사이클 (L1 캐시 맞으면 4~10 사이클) |
| 크기              | 수십 바이트 (x86-64: 16개 × 64bit)   | 수 GB ~ 수십 GB                       |
| 접근 시간 차이    | 메모리보다 **100~300배 빠름**        | 느림 (CPU가 멍때리는 주범)            |
| 용도              | CPU가 지금 당장 연산할 데이터만      | 대량 데이터 저장소     |

### 구조도
+-------------------+
|     Register      |   ← CPU 내부에 존재하는 기억장치
| (RAX, RBX, ...)   |   ← 이곳에서의 연산은 아주 빠르다
+-------------------+
↓ (1 사이클)
+-------------------+
|    L1 Cache       |   ← CPU 코어별 전용 (수십 KB)
+-------------------+
↓ (4~10 사이클)
+-------------------+
|    L2 Cache       |
+-------------------+
↓ (10~20 사이클)
+-------------------+
|    L3 Cache       |   ← 코어들 공유 (수 MB)
+-------------------+
↓ (50~300 사이클)
+-------------------+
|      DRAM         |   ← 메인 메모리 (RAM)
+-------------------+
↓ (수천 사이클)
+-------------------+
|   SSD / HDD       |
+-------------------+


**핵심 포인트**: CPU는 Register로만 연산함. 메모리에서 데이터 가져오면 그동안 stall (멍때림).

### 3. 실전 예시

#### 예시 1: add rax, rbx
- 메모리 접근: **0번**  
- 둘 다 레지스터 안에 있어서 매우 빠르게 끝남

#### 예시 2: 함수 호출 인자 전달 (System V ABI)
- 인자 1~6개: 레지스터로 넘김 (RDI, RSI, RDX, R10, R8, R9)  
- 인자 7개부터: 스택(메모리)에 push  
→ 속도가 빠른 레지스터를 최대한 활용하기 위해서

#### 예시 3: Pintos intr_frame
```c
struct intr_frame {
    uint64_t rip;
    uint64_t cs;
    uint64_t rflags;
    uint64_t rsp;
    uint64_t ss;
    uint64_t rax, rbx, rcx, rdx, rsi, rdi, ...;  // 모든 범용 레지스터 저장
};
```
인터럽트/시스템콜 오면 레지스터 상태 통째로 백업
→ 나중에 복구해서 컨텍스트 스위치 해야 하기에

#### 예시 4: 레지스터 꽉 차면?
컴파일러가 자동으로 스택 spill
임시로 메모리(스택)에 저장하고 필요할 때 다시 로드


## User Stack

User Stack = 각 프로세스별로 커널이 할당해준 유저 가상 메모리 영역 중에서 스택 부분

주소: 높은 주소에서 낮은 주소로 자람 (0x7fffffffffff ↓↓↓)
용도: 함수 호출, 로컬 변수, argument passing, return address 저장
크기: Pintos 기본 1MB (Pintos는 PGSIZE=4KB 단위로 grow 함)
```
높은 주소 (0x7fffffffffff)
┌────────────────────┐  ← 스택 처음 시작 (보통 PHYS_BASE 바로 아래)
│     Guard Page     │  ← 접근하면 page fault → 스택 오버플로우 잡음
├────────────────────┤
│                    │
│     스택 성장      │  ← push 하면 RSP ↓↓↓ (주소값 감소)
│     방향 ↓↓↓       │
│                    │
└────────────────────┘  ← 현재 RSP (스택 포인터)
낮은 주소 (힙 방향 ↑↑↑)
```
힙은 낮은 주소에서 위로 자라기에, 스택이 위에서 아래로 자라면 서로 만날 때까지 메모리를 자유롭게 쓸 수 있다.
```
높은 주소
┌────────────────────┐
│ "abc" (문자열)       ← 실제 문자열들 먼저 넣음
│ "def ghi"          
│ ...                
├────────────────────┤  ← word-align padding (8byte 맞추기 위해 0 채움)
│ 0x0 (NULL sentinel)  ← argv[argc] = NULL 필수!
├────────────────────┤
│ argv[argc-1] 주소     ← argv 포인터들 거꾸로 넣음
│ ...                
│ argv[0] 주소        
├────────────────────┤
│ 0x0 (fake return addr)  ← main 끝나도 어디로 갈지 몰라서 0 넣음
└────────────────────┘  ← 최종 RSP (여기서부터 main 시작)
```
#### 정리
1. 스택은 높은 주소 → 낮은 주소로 성장
2. 모든 건 8-byte align 강제
3. argv 마지막 NULL + fake return address 필수

## System call
### 시스템 콜 구조도 

단계 | 실행 모드 | 수행 주체 | 주요 동작
| :---: | :---: | :---: | :---: |
1. 요청 준비 | 유저 모드 (Ring 3) | 사용자 프로그램 | "요청 인자 준비: 시스템 콜 번호와 인자들(e.g., 파일 디스크립터, 주소)을 CPU 레지스터에 저장합니다."
2. 모드 전환 명령 | 유저 모드 (Ring 3) | 사용자 프로그램 | "특수 명령어 실행: 소프트웨어 인터럽트(e.g., INT 0x30, SYSCALL) 명령을 실행하여 커널 진입을 시도합니다."
3. 커널 진입 | 커널 모드 (Ring 0) | CPU / 커널 | "상태 저장 및 권한 상승: CPU가 유저 상태를 커널 스택에 저장하고, 실행 권한을 Ring 3에서 Ring 0으로 상승시킨 후, 인터럽트 벡터 테이블(IDT)을 통해 syscall_handler를 실행합니다."
4. 커널 연산 수행 | 커널 모드 (Ring 0) | 커널 코드 | "요청 처리: syscall_handler가 레지스터의 시스템 콜 번호를 확인하여 해당 커널 함수(e.g., sys_write)를 호출합니다. 커널은 하드웨어에 직접 접근하여 실제 연산(파일 쓰기 등)을 수행합니다."
5. 복귀 | 커널 모드 (Ring 0) → 유저 모드 (Ring 3) | 커널 / CPU | "결과 반환 및 권한 강등: 커널이 결과를 레지스터에 저장하고, 저장된 유저 상태를 복원하며 권한을 Ring 0에서 Ring 3으로 다시 강등합니다. 유저 프로그램은 다음 명령부터 실행을 재개합니다."




# 코드 / 실습
```c
```
