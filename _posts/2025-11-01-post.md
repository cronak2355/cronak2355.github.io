---
layout: post
title: "2025-11-01"
date: 2025-11-02 01:49:05 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---

# Today's Log(2025-11-01)
>오늘은 Week08의 토요일이다 이번 주차부터 웹 서버 제작에 들어간다.

---

## 오늘 한 일
- CSAPP 11.4.1~11.4.6 공부

---

## TIL
### CSAPP 11.4
소켓 인터페이스는 Unix I/O 함수와 함께 사용되어 네트워크 애플리케이션을 구축하는 함수들의 집합이다. 
모든 Unix 변형, Windows, Mac 시스템에 구현되어 있다.

![](/assets/img/images/2025-11-01-1.png)


---

### CSAPP 11.4.1

#### 핵심 개념

**관점에 따른 소켓의 의미:**
- Linux 커널 관점: 소켓은 통신의 끝점(endpoint)
- Linux 프로그램 관점: 소켓은 디스크립터를 가진 열린 파일

#### 주요 구조체

**sockaddr_in (인터넷 소켓 주소 구조체)**
```c
struct sockaddr_in {
    uint16_t sin_family;        /* 프로토콜 패밀리 (항상 AF_INET) */
    uint16_t sin_port;          /* 네트워크 바이트 순서의 포트 번호 */
    struct in_addr sin_addr;    /* 네트워크 바이트 순서의 IP 주소 */
    unsigned char sin_zero[8];  /* sizeof(struct sockaddr)로 패딩 */
};
```

**sockaddr (일반 소켓 주소 구조체)**
```c
struct sockaddr {
    uint16_t sa_family;    /* 프로토콜 패밀리 */
    char sa_data[14];      /* 주소 데이터 */
};
```

![](/assets/img/images/2025-11-01-2.png)


#### 주요 특징

- **크기**: 16바이트 구조체
- **바이트 순서**: IP 주소와 포트 번호는 항상 네트워크 바이트 순서(빅 엔디안)로 저장
- **타입 캐스팅 필요**: `connect`, `bind`, `accept` 함수는 프로토콜별 소켓 주소 구조체 포인터를 요구하지만, 일반 `sockaddr` 구조체 포인터를 기대하므로 캐스팅 필요

**편의를 위한 타입 정의:**
```c
typedef struct sockaddr SA;
```

---

### CSAPP 11.4.2

#### 함수 시그니처
```c
#include <sys/types.h>
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
// 반환: 성공 시 음수가 아닌 디스크립터, 오류 시 -1
```

#### 기능

소켓 디스크립터를 생성하는 함수로, 연결의 끝점이 될 소켓을 만든다.

#### 사용 예시
```c
clientfd = Socket(AF_INET, SOCK_STREAM, 0);
```

**파라미터 설명:**
- `AF_INET`: 32비트 IP 주소 사용
- `SOCK_STREAM`: TCP 연결을 위한 스트림 소켓
- `0`: 프로토콜 (일반적으로 0)

### 중요 포인트

- `socket`이 반환하는 디스크립터는 **부분적으로만 열린 상태**
- 아직 읽기/쓰기에 사용 불가능
- 클라이언트인지 서버인지에 따라 완전히 여는 방법이 다름
- **Best Practice**: `getaddrinfo` 함수를 사용하여 파라미터를 자동으로 생성해 프로토콜 독립적인 코드 작성

---

#### CSAPP 11.4.3

#### 함수 시그니처
```c
#include <sys/socket.h>

int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);
// 반환: 성공 시 0, 오류 시 -1
```

#### 기능

클라이언트가 서버와의 연결을 설정하기 위해 호출하는 함수이다.

#### 동작 방식

1. 소켓 주소 `addr`의 서버와 인터넷 연결을 시도
2. `addrlen`은 `sizeof(sockaddr_in)`
3. 연결이 성공적으로 설정되거나 오류가 발생할 때까지 **블로킹**
4. 성공 시, `clientfd` 디스크립터는 읽기/쓰기 준비 완료

### 연결 후 소켓 쌍
```
(x:y, addr.sin_addr:addr.sin_port)
```
- `x`: 클라이언트의 IP 주소
- `y`: 커널이 할당한 임시 포트 번호

### 주요 특징

- **블로킹 함수**: 연결이 완료될 때까지 대기
- **자동 포트 할당**: 클라이언트의 포트는 커널이 자동으로 할당

---

### CSAPP 11.4.4

#### 함수 시그니처
```c
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
// 반환: 성공 시 0, 오류 시 -1
```

#### 기능

서버의 소켓 주소를 소켓 디스크립터와 연결한다.

#### 파라미터

- `sockfd`: 소켓 디스크립터
- `addr`: 서버의 소켓 주소
- `addrlen`: `sizeof(sockaddr_in)`

#### 사용 목적

커널에게 `addr`에 있는 서버의 소켓 주소를 소켓 디스크립터 `sockfd`와 연결하도록 요청한다.

#### Best Practice

`socket`과 `connect`처럼, `getaddrinfo`를 사용하여 `bind`의 인자를 제공하는 것이 가장 좋은 방법이다.

---

### CSAPP 11.4.5

#### 함수 시그니처
```c
#include <sys/socket.h>

int listen(int sockfd, int backlog);
// 반환: 성공 시 0, 오류 시 -1
```

#### 기능

소켓을 **능동 소켓**에서 **수신 소켓**으로 변환한다.

#### 클라이언트 vs 서버

- **클라이언트**: 연결 요청을 시작하는 능동적 개체
- **서버**: 클라이언트로부터의 연결 요청을 기다리는 수동적 개체

#### 기본 동작

기본적으로 커널은 `socket` 함수로 생성된 디스크립터가 클라이언트 측의 **능동 소켓**이라고 가정한다.

서버는 `listen` 함수를 호출하여 커널에게 이 디스크립터가 서버에서 사용될 것임을 알린다.

#### 파라미터

- `sockfd`: 소켓 디스크립터
- `backlog`: 커널이 요청을 거부하기 전에 대기할 미처리 연결 요청 수에 대한 힌트
  - 일반적으로 1,024와 같은 큰 값으로 설정

#### 동작 원리

`listen` 함수는 `sockfd`를 능동 소켓에서 클라이언트의 연결 요청을 수락할 수 있는 **수신 소켓**으로 변환한다.

---

### CSAPP 11.4.6

#### 함수 시그니처
```c
#include <sys/socket.h>

int accept(int listenfd, struct sockaddr *addr, int *addrlen);
// 반환: 성공 시 음수가 아닌 연결 디스크립터, 오류 시 -1
```

#### 기능

서버가 클라이언트로부터의 연결 요청을 기다리는 함수이다.

#### 동작 방식

1. 수신 디스크립터 `listenfd`로의 클라이언트 연결 요청 대기
2. 클라이언트의 소켓 주소를 `addr`에 채움
3. 클라이언트와 통신하는 데 사용할 수 있는 **연결 디스크립터** 반환
4. Unix I/O 함수로 통신 가능

#### 수신 디스크립터 vs 연결 디스크립터

중요한 개념이다.

**수신 디스크립터 (Listening Descriptor):**
- 클라이언트 연결 요청의 끝점 역할
- 일반적으로 한 번 생성되어 서버의 수명 동안 존재
- 서버가 살아있는 동안 계속 유지

**연결 디스크립터 (Connected Descriptor):**
- 클라이언트와 서버 간에 설정된 연결의 끝점
- 서버가 연결 요청을 수락할 때마다 생성
- 서버가 클라이언트에 서비스하는 동안만 존재

![](/assets/img/images/2025-11-01-3.png)


#### 연결 수립 과정

**Step 1: 서버가 accept 호출**
- 서버가 `accept`를 호출하여 수신 디스크립터(예: descriptor 3)로의 연결 요청 대기
- 디스크립터 0-2는 표준 파일용으로 예약됨

**Step 2: 클라이언트가 connect 호출**
- 클라이언트가 `connect` 함수를 호출
- `listenfd`로 연결 요청 전송
- `connect`에서 블로킹됨

**Step 3: 연결 수립**
- `accept` 함수가 새로운 연결 디스크립터 `connfd`(예: descriptor 4) 생성
- `clientfd`와 `connfd` 간 연결 설정
- `connfd`를 애플리케이션에 반환
- 클라이언트는 `connect`에서 반환
- 이제 `clientfd`와 `connfd` 간 연결 수립 완료

---

## 전체 흐름 요약

### 클라이언트 측
```
1. socket()      - 소켓 생성
2. getaddrinfo() - 주소 정보 획득
3. connect()     - 서버에 연결 (블로킹)
4. rio_writen()  - 데이터 전송
5. rio_readlineb() - 데이터 수신
6. close()       - 연결 종료
```

### 서버 측
```
1. socket()      - 소켓 생성
2. getaddrinfo() - 주소 정보 획득
3. bind()        - 소켓 주소 바인딩
4. listen()      - 수신 소켓으로 변환
5. accept()      - 연결 요청 대기 (블로킹)
6. rio_readlineb() - 데이터 수신
7. rio_writen()  - 데이터 전송
8. close()       - 연결 종료
```

### 핵심 개념

1. **소켓 생성**: `socket()`으로 부분적으로 열린 소켓 생성
2. **클라이언트**: `connect()`로 서버에 연결하여 소켓 완전히 오픈
3. **서버**: `bind()` → `listen()` → `accept()` 순서로 연결 준비 및 수락
4. **디스크립터 구분**: 
   - 수신 디스크립터: 서버 수명 동안 유지
   - 연결 디스크립터: 클라이언트 서비스 동안만 유지
5. **블로킹 함수**: `connect()`와 `accept()`는 모두 블로킹 함수
---

## 코드 / 실습
```c
//오늘은 코드를 작성하지 않았다.
```

