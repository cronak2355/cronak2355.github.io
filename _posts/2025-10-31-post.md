---
layout: post
title: "2025-10-31"
date: 2025-11-01 01:49:05 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---




# Today's Log(2025-10-31)

>오늘은 Week08의 금요알이다 이번 주차부터 웹 서버 제작에 들어간다.



---



## 오늘 한 일

- CSAPP 11.1~11.3 공부



---



## TIL

### **CSAPP 11.1**

모든 네트워크 응용 프로그램은 클라이언트-서버 모델에 기초하고 있다.

이 모델은 한 개의 서버 프로세스와 한 개 이상의 클라이언트 프로세스로 구성된다.



서버는 리소스를 관리하고, 이 리소스를 조작해서 클라이언트를 위한 서비스를 제공한다.



클라이언트-서버 모델에서 기본적인 연산은 트랜잭션이며 4단계로 구성된다



![](/assets/img/images/2025-10-31-1.png)





1. 클라이언트가 서비스를 필요로 할 때, 클라이언트는 요청을 서버에 보내 트랜잭션을 개시한다. 

예를 들어 웹 브라우저가 파일을 필요로 할 때, 웹 서버로 요청을 보낸다.



2. 서버는 요청을 받고, 해석하고, 자신의 자원들을 적절한 방법으로 조작한다. 

예를 들어 웹 서버가 브라우저로부터 요청을 받을 때, 디스크 파일을 읽는다.



3. 서버는 응답을 클라이언트로 보내고, 그 후에 다음 요청을 기다린다.

에를 들어 웹 서버는 이 파일을 다시 클라이언트로 돌려보낸다.



4. 클라이언트는 응답을 받고 이것을 처리한다. 

예를 들어 웹 브라우저가 서버로부터 페이지를 한 개 받은 후, 이것을 스크린에 디스플레이한다.

된다.



### **CSAPP 11.2**

#### 1. 네트워크 = I/O 디바이스



클라이언트와 서버는 별도의 호스트에서 돌아가며, **호스트에게 네트워크는 단지 또 다른 하나의 I/O 디바이스**이다.



![](/assets/img/images/2025-10-31-2.png)



그림에서처럼 네트워크는 I/O 버스를 통해 데이터를 수신하며 일반 디바이스와 같은 취급을 받는다.



호스트는 **네트워크 어댑터**를 통해 정보를 주고받으며, 이러한 호스트들이 모여서 허브를 형성한다.



---



#### 2. 이더넷 세그먼트 (Ethernet Segment)



![](/assets/img/images/2025-10-31-3.png)



이러한 구조를 **이더넷 세그먼트**라 부른다.



#### 특징



- 호스트와 허브 간의 연결은 **동일한 최대 비트 대역폭**(100Mb/s나 1Gb/s)을 가진다

- 허브는 호스트들의 정보를 어댑터를 통해 받아 허브의 포트로 전달한다



#### 이더넷 어댑터



어댑터와 포트들을 **이더넷 어댑터**라고 부르며, 각 이더넷 어댑터는:

- 어댑터의 **비휘발성 메모리**에 저장된

- **고유한 48비트 주소**(MAC Address)를 가진다



#### 프레임 (Frame)



호스트는 **프레임**이라 부르는 비트들을 이더넷 세그먼트의 다른 호스트에 보낼 수 있다.



각 프레임의 구조:

```

[헤더: 소스/목적지/길이] + [데이터]

```



- 모든 호스트 어댑터가 프레임을 볼 수 있지만

- 목적지 호스트만이 프레임을 읽는다



---



#### 3. 브릿지형 이더넷 (Bridged Ethernet)



![](/assets/img/images/2025-10-31-4.png)



여러 이더넷 세그먼트가 모여 **브릿지형 이더넷**이라고 하는 더 큰 LAN을 구성할 수 있다.



#### 대역폭



- **브릿지-브릿지**: 1Gb/s

- **허브-브릿지**: 100Mb/s



#### 동작 방식



브릿지는 **분산 알고리즘**을 사용하여 다음을 알 수 있다.

1. 어떤 호스트가 어떤 포트에서 도달 가능한지 자동으로 학습

2. 필요한 경우 선택적으로 하나의 포트에서 다른 포트로 프레임을 복사



---



#### 4. LAN과 라우터



![](/assets/img/images/2025-10-31-5.png)



LAN(Local Area Network)은 라우터를 통해 다른 네트워크와 연결될 수 있다.



#### 라우터 구조



![](/assets/img/images/2025-10-31-6.png)



라우터:

- 각 네트워크 간의 연결을 구성하는 특수한 컴퓨터

- **호환되지 않는 네트워크 기술 간의 데이터 전송**을 가능하게 함

- 자신이 연결된 각 네트워크마다 **어댑터(포트) 하나씩** 보유



---



#### 5. 인터넷 프로토콜을 통한 데이터 전송



![](/assets/img/images/2025-10-31-7.png)



호환성이 없는 LAN을 통해 데이터를 전송하기 위해 인터넷 프로토콜을 사용하는 과정이다.



#### 전송 과정 (Host A → Host B)



#### **1단계: 시스템 호출**

호스트 A의 클라이언트가 시스템 호출을 실행하여 클라이언트의 가상 주소 공간에 있는 데이터를 커널 버퍼로 복사한다.



#### **2단계: 헤더 추가 (캡슐화)**

호스트 A의 프로토콜 소프트웨어는 데이터에 헤더를 덧붙여 LAN1 프레임을 생성한다:



```

[LAN1 프레임 헤더] + [인터넷 패킷 헤더] + [사용자 데이터]

```



- **인터넷 헤더**: 호스트 B를 최종 목적지로 설정

- **LAN1 프레임 헤더**: 라우터를 다음 목적지로 설정



> 💡 **캡슐화(Encapsulation)**: LAN1 프레임의 페이로드는 인터넷 패킷이며, 그 안의 페이로드는 실제 사용자 데이터이다. 이러한 캡슐화 방식은 **인터네트워킹의 핵심 개념** 중 하나이다.



#### **3단계: LAN1 전송**

LAN1 어댑터가 프레임을 네트워크로 전송한다.



#### **4단계: 라우터 수신**

프레임이 라우터에 도달하면, 라우터의 LAN1 어댑터가 프레임을 수신하여 프로토콜 소프트웨어에 전달한다.



#### **5단계: 라우팅 및 헤더 교체**

라우터는:

1. 인터넷 패킷 헤더에서 **목적지 인터넷 주소** 추출

2. **라우팅 테이블**을 참조하여 다음 목적지(LAN2) 결정

3. 기존 **LAN1 프레임 헤더 제거**

4. 호스트 B를 목적지로 하는 **새로운 LAN2 프레임 헤더 추가**

5. 프레임을 LAN2 어댑터에 전달



#### **6단계: LAN2 전송**

라우터의 LAN2 어댑터가 프레임을 네트워크로 전송한다.



#### **7단계: 호스트 B 수신**

프레임이 호스트 B에 도달하면, 호스트 B의 어댑터가 프레임을 수신하여 프로토콜 소프트웨어에 전달한다.



#### **8단계: 헤더 제거 및 데이터 전달**

호스트 B의 프로토콜 소프트웨어는:

1. 패킷 헤더와 프레임 헤더를 제거

2. 서버가 시스템 호출을 통해 데이터를 읽으면

3. 해당 데이터를 서버의 가상 주소 공간으로 복사



---



#### 핵심 개념 정리



#### 이더넷 어댑터 (Ethernet Adapter)

- 48비트 고유 주소 (MAC Address)

- 비휘발성 메모리에 저장

- 네트워크 카드의 물리적 주소



#### 프레임 (Frame)

- 네트워크 전송의 기본 단위

- 구조: `[헤더] + [데이터]`

- 같은 세그먼트 내에서만 유효



#### 캡슐화 (Encapsulation)

```

[사용자 데이터]

  ↓ 인터넷 계층

[인터넷 헤더 + 데이터] (패킷)

  ↓ 링크 계층

[프레임 헤더 + 패킷] (프레임)

```

- 각 계층마다 헤더 추가/제거

- 인터네트워킹의 핵심 원리



#### 대역폭

- 허브-호스트: 100Mb/s

- 브릿지-브릿지: 1Gb/s

- 허브-브릿지: 100Mb/s



---



#### 요약



1. **네트워크는 I/O 디바이스**

   - 호스트 입장에서는 단순한 I/O 장치



2. **이더넷 세그먼트**

   - 허브 중심의 작은 네트워크

   - 프레임 단위 통신



3. **브릿지**

   - 여러 세그먼트를 연결

   - 선택적 프레임 복사



4. **라우터**

   - 서로 다른 네트워크를 연결

   - 프레임 헤더를 교체하여 라우팅



5. **캡슐화**

   - 계층마다 헤더 추가/제거

   - 인터네트워킹의 핵심 원리

   

   

### **CSAPP 11.3**



글로벌 IP 인터넷은 1969년부터 다양한 형태로 존재해 왔다. 



![](/assets/img/images/2025-10-31-8.png)





그림은 인터넷 클라이언트-서버 애플리케이션의 기본 하드웨어 및 소프트웨어 구조를 보여준다.



각 인터넷 호스트는 **TCP/IP 프로토콜**(Transmission Control Protocol/Internet Protocol)을 구현하는 소프트웨어를 실행하며, 이는 모든 현대 컴퓨터 시스템에서 지원된다.



인터넷 클라이언트와 서버는 소켓 인터페이스 함수와 Unix I/O 함수의 혼합을 사용하여 통신한다.



TCP/IP는 실제로 프로토콜의 패밀리이며, 각 프로토콜은 다양한 기능에 기여한다:



- **IP**: 기본 네이밍 스키마와 **데이터그램**(datagram)으로 알려진 패킷을 한 인터넷 호스트에서 다른 호스트로 보낼 수 있는 전달 메커니즘을 제공한다. IP 메커니즘은 신뢰할 수 없다는 점에서, 데이터그램이 네트워크에서 손실되거나 중복될 경우 복구를 시도하지 않는다.



- **UDP**(Unreliable Datagram Protocol): IP를 약간 확장하여, 데이터그램이 호스트 간이 아닌 프로세스 간으로 전송될 수 있도록 한다. 데이터를 잃을 수도 있지만 더 빠르다.



- **TCP**: IP 위에 구축된 복잡한 프로토콜로, 프로세스 간 신뢰할 수 있는 전이중(양방향) 연결을 제공한다.



호스트의 특징



- 호스트 집합은 32비트 IP 주소 집합으로 매핑된다.

- IP 주소 집합은 인터넷 도메인 네임이라는 식별자 집합으로 매핑된다.

- 한 인터넷 호스트의 프로세스는 연결을 통해 다른 인터넷 호스트의 프로세스와 통신할 수 있다.



---



#### 11.3.1 IP 주소



IP 주소는 부호 없는 32비트 정수이다. 네트워크 프로그램은 아래 표시된 IP 주소 구조체에 IP 주소를 저장한다.



```c

/* IP address structure */

struct in_addr {

    uint32_t s_addr; /* Address in network byte order (big-endian) */

};

```



인터넷 호스트는 서로 다른 **호스트 바이트 순서(리틀 엔디안 또는 빅 엔디안)**을 가질 수 있기에, 

TCP/IP는 패킷 헤더에서 전달되는 IP 주소와 같은 모든 정수 데이터 항목에 대해 균일한 **네트워크 바이트 순서(빅 엔디안)**를 정의한다. 



서로 다른 구조의 호스트 간 통신을 위해 이 약속이 필요하다.



IP 주소 구조체의 주소는 호스트 바이트 순서가 리틀 엔디안이더라도 항상 (빅 엔디안) 네트워크 바이트 순서로 저장된다. Unix는 네트워크와 호스트 바이트 순서 간 변환을 위한 다음 함수를 제공한다:



```c

#include <arpa/inet.h>



uint32_t htonl(uint32_t hostlong);

uint32_t ntohl(uint32_t netlong);

// 반환: 호스트 바이트 순서의 값



uint16_t htons(uint16_t hostshort);

uint16_t ntohs(uint16_t netshort);

// 반환: 호스트 바이트 순서의 값

```



`htonl` 함수는 부호 없는 32비트 정수를 호스트 바이트 순서에서 네트워크 바이트 순서로 변환한다. 



`ntohl` 함수는 부호 없는 32비트 정수를 네트워크 바이트 순서에서 호스트 바이트 순서로 변환한다. 



`htons`와 `ntohs` 함수는 부호 없는 16비트 정수에 대한 해당 변환을 수행한다. 64비트 값을 조작하는 동등한 함수는 없다.



IP 주소는 일반적으로 십진수로 사람에게 제시되며, 각 바이트를 십진수 값으로 표현하고 다른 바이트와 마침표로 구분한다. 이를 **점선 십진 표기법(Dotted-decimal notation)**혹은 **점-십진 표기법**이라고 한다. 예를 들어, 128.2.194.242는 주소 0x8002c2f2의 십진수 표현이다.



Linux 시스템에서는 `hostname` 명령을 사용하여 자신의 호스트의 점-십진 주소를 확인할 수 있다:



```bash

linux> hostname -i

128.2.210.175

```



애플리케이션 프로그램은 `inet_pton`과 `inet_ntop` 함수를 사용하여 IP 주소와 점-십진 문자열 간을 변환할 수 있다:



```c

#include <arpa/inet.h>



int inet_pton(AF_INET, const char *src, void *dst);

// 반환: 성공 시 1, src가 유효하지 않은 점-십진이면 0, 오류 시 -1



const char *inet_ntop(AF_INET, const void *src, char *dst, socklen_t size);

// 반환: 성공 시 점-십진 문자열 포인터, 오류 시 NULL

```



이러한 함수 이름에서 "n"은 네트워크를 의미하고 "p"는 표현을 의미한다.



32비트 IPv4 주소(AF_INET) 또는 128비트 IPv6 주소(AF_INET6)를 조작할 수 있다 하지만

책에서는 다루지 않는다.



`inet_pton` 함수는 점-십진 문자열(`src`)을 네트워크 바이트 순서의 이진 IP 주소(`dst`)로 변환한다. 



`src`가 유효한 점-십진 문자열을 가리키지 않으면 0을 반환한다. 



다른 오류는 -1을 반환하고 `errno`를 설정한다. 



마찬가지로, `inet_ntop` 함수는 네트워크 바이트 순서의 이진 IP 주소(`src`)를 해당하는 점-십진 표현으로 변환하고, 결과 null 종료 문자열의 최대 `size` 바이트를 `dst`에 복사한다.



---



#### 인터넷 도메인 네임



인터넷 클라이언트와 서버는 서로 통신할 때 IP 주소를 사용한다.



IP 주소는 컴퓨터가 이해하기 쉬운 큰 숫자이지만, 사람이 기억하고 사용하기는 어렵기 때문에, 도메인 네임을 사용한다.



도메인 네임은 마침표로 구분된 단어(문자, 숫자, 대시) 시퀀스이다(예: `whaleshark.ics.cs.cmu.edu`).



도메인 네임 집합은 계층 구조를 형성하며, 각 도메인 네임은 계층 내 위치를 인코딩한다. 예시가 이를 이해하는 가장 쉬운 방법이다. 



아래 그림은 도메인 네임 계층의 일부를 보여준다.



![](/assets/img/images/2025-10-31-9.png)





계층 구조는 트리로 표현된다.



트리의 노드는 루트로 돌아가는 경로로 형성된 도메인 네임을 나타낸다. 



서브트리는 서브도메인으로 참조된다. 계층의 첫 번째 레벨은 이름 없는 루트 노드이다. 



다음 레벨은 ICANN(Internet Corporation for Assigned Names and Numbers)이라는 비영리 조직이 정의한 1차 도메인 네임의 모음이다. 



일반적인 1차 도메인에는 com, edu, gov, org, net이 포함된다.



다음 레벨에는 `cmu.edu`와 같은 2차 도메인 네임이 있으며, 이는 ICANN의 다양한 공인 에이전트가 선착순으로 할당한다. 조직이 2차 도메인 네임을 받으면, 서브도메인 내에서 `cs.cmu.edu`와 같은 다른 새 도메인 네임을 자유롭게 생성할 수 있다.



인터넷은 도메인 네임 집합과 IP 주소 집합 간의 매핑을 정의한다.



1988년까지 이 매핑은 HOSTS.TXT라는 단일 텍스트 파일에서 수동으로 유지되었다. 



허나 그 이후로 매핑은 DNS(Domain Name System)로 알려진 전 세계에 분산된 데이터베이스에서 유지되고 있다. 



개념적으로, DNS 데이터베이스는 수백만 개의 호스트 엔트리로 구성되며, 각 엔트리는 도메인 네임 집합과 IP 주소 집합 간의 매핑을 정의한다. 



Linux `nslookup` 프로그램을 사용하여 DNS 매핑의 속성을 탐색할 수 있으며, 이는 도메인 네임과 연관된 IP 주소를 표시한다.



#### 1. 루프백 주소 (localhost)



각 인터넷 호스트에는 로컬로 정의된 도메인 네임 `localhost`가 있으며, 이는 항상 **루프백 주소** `127.0.0.1`로 매핑된다:



```bash

linux> nslookup localhost

Address: 127.0.0.1

```



`localhost` 네임은 동일한 머신에서 실행 중인 클라이언트와 서버를 참조하는 편리하고 이식 가능한 방법을 제공하며, 이는 개발 및 디버깅 중에 특히 유용할 수 있다.



#### 2. 일대일 매핑

간단한 도메인 네임과 `localhost` 사이의 매핑은 일대일이다:



```bash

linux> nslookup whaleshark.ics.cs.cmu.edu

Address: 128.2.210.175

```

### 3. 다대일 매핑 (여러 이름 → 하나의 IP 주소)

그러나 일부 경우에는 여러 도메인 네임이 동일한 IP 주소로 매핑된다:



```bash

linux> nslookup cs.mit.edu

Address: 18.62.1.6



linux> nslookup eecs.mit.edu

Address: 18.62.1.6

```

#### 4. 다대다 매핑 (여러 이름 $\leftrightarrow$ 여러 IP 주소)

보통, 여러 도메인 네임이 동일한 여러 IP 주소 집합으로 매핑된다:



```bash

linux> nslookup www.twitter.com

Address: 199.16.156.6

Address: 199.16.156.70

Address: 199.16.156.102

Address: 199.16.156.230



linux> nslookup twitter.com

Address: 199.16.156.102

Address: 199.16.156.230

Address: 199.16.156.6

Address: 199.16.156.70

```

#### 5. 매핑되지 않은 도메인 네임

마지막으로, 일부 유효한 도메인 네임은 어떤 IP 주소에도 매핑되지 않는다는 점을 알 수 있다:



```bash

linux> nslookup edu

*** Can't find edu: No answer



linux> nslookup ics.cs.cmu.edu

*** Can't find ics.cs.cmu.edu: No answer

```



---



#### 인터넷 연결



인터넷에서 클라이언트와 서버는 **연결(Connection)**을 통해 통신한다.



이 연결은 신뢰성을 보장하며, 데이터는 양방향으로 동시에 흐른다.



1. 소켓 (통신 끝점)연결의 시작점과 끝점은 **소켓(Socket)**이며, 각 소켓은 소켓 주소를 가진다.$$\text{소켓 주소} = \text{IP 주소 : 포트 번호}$$



IP 주소: 통신하는 **호스트(컴퓨터)**를 식별한다.



포트 번호: 호스트 내에서 통신하는 **프로세스(응용 프로그램)**를 식별한다.



```

(cliaddr:cliport, servaddr:servport)

```



여기서 `cliaddr`은 클라이언트의 IP 주소, `cliport`는 클라이언트의 포트, `servaddr`은 서버의 IP 주소, `servport`는 서버의 포트이다. 



아래 그림은 웹 클라이언트와 웹 서버 간의 연결을 보여준다.



![](/assets/img/images/2025-10-31-10.png)





이 예에서 웹 클라이언트의 소켓 주소는 다음과 같다:



```

128.2.194.242:51213

```



여기서 포트 51213은 커널이 할당한 임시 포트이다. 웹 서버의 소켓 주소는 다음과 같다:



```

208.216.181.15:80

```



여기서 포트 80은 웹 서비스와 연관된 잘 알려진 포트이다. 소켓 쌍은 이 연결을 고유하게 식별한다:



```

(128.2.194.242:51213, 208.216.181.15:80)

```



---



## 코드 / 실습

```c

//오늘은 코드를 작성하지 않았다.

```




