---
layout: post
title: "2025-10-24"
date: 2025-10-25 03:36:13 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-10-24)
>오늘은 Week07의 2번째 날이다. 오늘은 개념을 공부하면서 기초를 쌓는 것을 목표로 하기로 하였다.

---

## 오늘 한 일
- CSAPP 9.8 ~ 9.9.3 공부 
- malloc lab 

---

## TIL
### **copy-on-write **  

copy on write 한국말로 하면 쓰기 중 복사, 말 그대로 쓰기 중 복사를 하는 개념이다.

프로세스는 각자의 가상 메모리 영역 및 공유 객체와 물리 메모리를 가진다.

Copy-on-Write는 각 프로세스가 같은 물리 페이지를 공유하도록 매핑해 두고,
읽기만 할 때는 그대로 공유한다. 

하지만 어느 한 프로세스가 쓰기를 시도하면 페이지 폴트가 발생한다.

운영체제는 그 시점에 새로운 물리 페이지를 할당하고 원래 데이터를 복사한 뒤,
해당 프로세스의 페이지 테이블 엔트리를 새 페이지로 갱신한다.

이렇게 하면 불필요한 메모리 복사를 피하면서도, 각 프로세스가 독립적으로 메모리를 수정할 수 있다.

### **fork**

이제 fork 함수에 대해 알아보자  
fork()는 새로운 프로세스를 복제하여 만드는 함수이며
copy-on-write 기법을 통해 fork의 작동 방식을 상세히 알 수 있다.

- 프로세스가 fork()를 호출한다.
- 운영체제가 새로운 프로세스를 생성한다.
- 코드, 데이터, 힙, 스택 등 메모리 구조를 복사한 것처럼 보이게 만든다.
- 실제로는 Copy-on-Write 기법을 사용해서, 쓰기 전까지는 같은 물리 메모리를 공유한다.
- 이제 원래 있던 프로세스와 새로운 프로세스가 동시에 실행된다.
- 둘 다 fork() 호출 직후의 코드부터 실행을 이어간다.
- 반환값을 통해 원래 프로세스와 새로운 프로세스를 구분할 수 있다.

### **execve**  

또 execve 함수에 대해 알아보자 
execve()는 현제 프로세스를 새롭게 갈아치우는 함수이며
copy-on-write 기법을 통해 execve의 작동 방식을 이해하는데 도움을 받을 수 있다.


- 프로세스가 execve()를 호출한다.
- 운영체제가 현재 프로세스의 코드, 데이터, 힙, 스택 영역을 제거한다.
- 지정한 실행 파일을 디스크에서 읽어와 프로세스의 가상 메모리 공간에 매핑한다.
- .text 섹션 → 코드 영역
- .data 섹션 → 데이터 영역
- 스택을 초기화 한다.
- 환경 변수(envp)와 인자(argv)를 스택에 적재
- CPU의 명령 포인터를 새 프로그램의 시작 지점으로 옮긴다.
- 이제 기존 프로그램은 완전히 사라지고, 새로운 프로그램이 실행된다.


### **동적 메모리 할당**

동적 메모리 할당
동적 메모리 할당은 프로그램 실행 중 필요한 만큼의 메모리를 요청하고, 사용이 끝나면 해제하는 과정이다.
이 작업은 주로 힙 영역에서 이루어지며, 프로그래머는 포인터를 통해 할당된 메모리를 직접 접근하고 관리할 수 있다.
가상 메모리를 효율적으로 활용하기 위해서는 **할당기(allocator)**가 필요하다.
가상 메모리는 논리적으로는 연속적이지만, 실제 물리 메모리에서는 비연속적으로 배치되며, 크기도 동적으로 변한다.
할당기는 힙을 다양한 크기의 블록(block) 단위로 나누어 관리하며, 각 블록은 할당된 상태이거나 가용 상태이다.
할당기는 크게 두 가지 유형으로 나뉜다:
- 명시적 할당기: 프로그래머가 직접 메모리를 요청하고 또 해제해야 한다.
- 묵시적 할당기: **가비지 컬렉터(Garbage Collector)**가 자동으로 사용되지 않는 블록을 회수하여 메모리를 관리한다.

### **malloc과 free**

malloc 함수는 자료형의 바이트 크기를 기준으로 적절히 정렬된 메모리 블록의 주소를 리턴한다.
정렬은 32bit 모드는 8의 배수 64bit에서는 16의 배수로 정렬한다.

malloc은 프로그램이 사용할 수 있는 가상 메모리보다 더 큰 크기의 메모리 블록을 요청하는 경우 NULL을 리턴하고 errno를 설정한다. 또한 malloc은 리턴하는 메모리를 초기화 하지 않는다.

초기화 된 메모리를 리턴받고 싶을 경우 calloc을 사용할 수 있다. 
만약 이전에 할당된 블록의 크기를 변경하려고 할 경우 realloc을 사용할 수 있다.

sbrk 함수는 커널의 brk 포인터에 incr을 더해서 힙을 늘리거나 줄인다.
성공한다면 더하기 전 brk값을 리턴하고 성공하지 못한다면 -1을 리턴하고 errno를 ENOMEM으로 설정한다. incr이 0일 경우 sbrk는 현재의 brk 값을 리턴한다.

ptr 인자는 할당된 블록의 시작을 가리킨다.



### **왜 동적 메모리 할당인가?**

가장 큰 이유는 프로그램 실행 전에 자료 구조의 크기를 알 수 없는 경우가 종종 있기 때문이다.
또한 배열 같이 크기를 정하여 프로그램을 작성하는 경우 프로그램의 확장 범위를 좁히게 될 수 있다. 수백만 줄의 코드에서 매 번 배열 범위를 바꿀 수는 없지 않은가?

따라서 실행 중 필요한 만큼의 메모리를 동적으로 할당하고, 상황에 따라 해제하거나 크기를 조절할 수 있는 방식이 훨씬 유연하고 안전하다.

### ** 할당기 요구사항**

명시적 할당기는 다소 엄격한 제한사항 내에서 동작해야 한다.
- 임의의 요청 순서 처리하기
응용 프로그램은 각각의 가용 블록이 이전의 할당 요청에 의해 현재 할당된 블록에 대응되어야 한다는 제한사항을 만족하면서 임의의 순서로 할당과 반환요청을 할 수 있다. 그래서 할당기는 할당과 반환 요청의 순서에 대해서는 아무 가정도 할 수 없다. 예를 들어, 할당기는 모든 할당 요청이 대응되는 요청이 함께 존재한다거나 쌍을 이루는 할당과 반환 free 요청이 연속된다는 가정을 할 수 없다. 
- 요청에 즉시 응답하기, 블록 정렬하기(정렬 요건)
할당기는 블록들을 어떤 종류의 데이터 객체라도 저장할 수 있도록 하는 방식으로 정렬해야 한다.
- 힙만 사용하기
확장성을 갖기 위해서 할당기가 사용하는 비확정성 자료 구조들은 힙 자체에 저장되어야 한다.
- 할당된 블록을 수정하기 않기
할당기는 가용 블록을 조작하거나 변경할 수만 있다. 특히, 일단 블록이 할당되면 이들을 수정하거나 이동하지 않는다. 그래서 할당된 블록들을 압축하는 것 같은 기법들은 허용되지 않는다.

---

## 코드 / 실습
- 오늘은 코드를 작성하지 않았다.

