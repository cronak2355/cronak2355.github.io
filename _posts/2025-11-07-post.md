---
layout: post
title: "2025-11-07"
date: 2025-11-08 01:29:31 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-11-07)
>오늘은 Week09의 발제날이다 이번 주차부터 pintos 프로젝트에 들어간다.

---

# 오늘 한 일
- thread 공부
- interrupt 공부
- timer.c 공부

---

# TIL
## interrupt
### 1. 인터럽트의 기본 개념
인터럽트는 "CPU에게 긴급한 처리를 요청하는 신호" 또는 **"실행 흐름을 중단시키는 이벤트"**를 의미한다.

프로그램 실행과의 관계

CPU는 프로그램의 명령어를 순차적으로 실행한다. 
하지만 실행 중에 외부 하드웨어(타이머, 키보드 등)나 예외 상황이 발생하면, 현재 작업을 잠시 중단하고 해당 이벤트를 처리한 후 다시 원래 작업으로 돌아간다.

구분 | 책 읽기 (프로그램 실행) | 초인종 (인터럽트)
| :---: | :---: | :---: |
특징 | 순차적으로 한 페이지씩 읽어나간다. |갑자기 울려서 하던 일을 멈추게 만들고, 처리 후 다시 읽던 곳으로 돌아간다.

인터럽트가 없다면 CPU는 이벤트 발생 여부를 계속 확인해야 하는 폴링(Polling) 방식을 사용해야 하며, 이는 CPU 자원을 낭비하게 된다.

#### 폴링(Polling) 
컴퓨터 시스템에서 CPU가 주변 장치(I/O 장치)의 상태를 주기적으로 반복하여 확인하는 방식

### 2. 인터럽트의 종류 및 특징

구분 | 하드웨어 인터럽트 | 소프트웨어 인터럽트 (예외/트랩)발생 
| :---: | :---: | :---: |
원인 | 외부 하드웨어 장치의 신호 | 프로그램 실행 중 발생하는 예외 상황 
예시 | 타이머, 키보드 입력, 디스크 I/O 완료, 네트워크 패킷 도착 | 0으로 나누기, 잘못된 메모리 접근, 시스템 콜
예측 가능성 | 비동기적 (언제 발생할지 예측 불가) | 동기적 (특정 명령어 실행 시 발생)
처리 방식 | 인터럽트 핸들러(Interrupt Handler)로 점프 | 예외 핸들러(Exception Handler) 또는 시스템 콜 핸들러로 점프

### 3. 인터럽트의 동작 과정

인터럽트가 발생했을 때 CPU가 처리하는 과정은 다음과 같다.

#### 1단계: 인터럽트 발생 감지

하드웨어가 CPU에 인터럽트 신호 전송
CPU는 매 명령어 실행 후 인터럽트 발생 여부 확인

#### 2단계: 현재 상태 저장 (Context Saving)

프로그램 카운터(PC): 다음에 실행할 명령어 주소
레지스터 값들: CPU 레지스터에 저장된 데이터
프로세서 상태 플래그

#### 3단계: 인터럽트 핸들러 실행

인터럽트 벡터 테이블(Interrupt Vector Table)을 참조하여 해당 인터럽트 핸들러 함수로 점프

#### 4단계: 상태 복원 및 복귀 (Context Restoring)

저장했던 레지스터와 PC 값 복원
중단되었던 지점부터 프로그램 재개

>실생활 비유
57페이지 2번째 줄을 읽는 도중...
초인종이 울림 ← **인터럽트 발생**
→ 책갈피를 57페이지 2번째 줄에 끼움 (상태 저장)
→ 문 열어서 택배 수령 (인터럽트 처리)
→ 다시 책갈피가 있는 곳으로 (상태 복원)
57페이지 2번째 줄부터 다시 읽기 시작

### 4. Polling vs Interrupt
CPU가 이벤트를 감지하는 두 가지 방식의 비교

항목 | Polling (폴링) | Interrupt (인터럽트)
| :---: | :---: | :---: |
동작 | 방식CPU가 주기적으로 이벤트 발생 여부를 확인 | 이벤트 발생 시 하드웨어가 CPU에 신호 전송 |
CPU 효율성 | 낮음 (계속 확인만 하느라 낭비) | 높음 (이벤트 발생 시에만 처리)
응답| 속도느림 (다음 확인 주기까지 대기) | 빠름 (즉시 처리 가능)
구현 복잡도 | 단순함 | 복잡함 (핸들러, 동기화 필요)사용 
사례 | 간단한 시스템, 임베디드 | 대부분의 현대 컴퓨터 시스템

### 5. 인터럽트와 동기화 문제
인터럽트는 언제든 발생할 수 있기 때문에, 여러 실행 흐름이 공유 자원에 동시 접근할 때 **경쟁 조건(Race Condition)**이 발생할 수 있다.

>경쟁 조건의 예시
[스레드 A가 리스트 수정 중]
1. 새 노드 생성
2. 포인터 연결 시작...
   → [타이머 인터럽트 발생!]
   → timer_interrupt()도 같은 리스트 접근
   → 데이터 손상
3. 포인터 연결 완료... (이미 망가진 상태)

해결책: 인터럽트 제어

방식 | intr_disable() | intr_enable()
| :---: | :---: | :---: |
기능 | 인터럽트를 일시적으로 비활성화 | 인터럽트를 다시 활성화사용 
목적 | 임계 영역(Critical Section) 보호 | 정상 동작으로 복귀
주의사항 | 너무 오래 끄면 다른 인터럽트를 놓칠 수 있음 | 반드시 끈 만큼 다시 켜야 함

#### 사용 패턴:
```
intr_disable();           // 인터럽트 끄기
  공유 자료구조 수정      // 안전한 작업
  리스트에 항목 추가
intr_enable();            // 인터럽트 켜기
```

### 6. Pintos에서의 타이머 인터럽트

#### 타이머 인터럽트의 역할
- Pintos에서는 1밀리초마다 타이머 인터럽트가 발생하여 다음 작업을 수행한다.

### 시간 추적 
- 시스템 시간(ticks) 업데이트
스레드 스케줄링: CPU 시간 할당 및 스레드 전환
Alarm 기능: 잠든 스레드를 깨울 시간인지 확인

#### Alarm 구현과의 연관성
구분 | timer_sleep() (스레드 재우기) | timer_interrupt() (매 tick 호출)
| :---: | :---: | :---: |
역할 | 스레드를 block 상태로 전환하고 깨어날 시간 기록 | 현재 시간과 비교하여 깨울 스레드가 있는지 확인
실행 주체 | 스레드가 직접 호출 | 타이머 하드웨어가 자동 호출
처리 내용 | Sleep queue에 스레드 추가 | Sleep queue 순회하여 unblock 처리

이렇게 인터럽트를 활용하면 busy waiting 없이 효율적으로 sleep 기능을 구현할 수 있다.

### 7. 인터럽트 처리 시 주의사항
#### 빠른 처리 (Fast Processing)

인터럽트 핸들러는 가능한 한 짧고 빠르게 실행되어야 한다.
너무 오래 걸리면 다른 인터럽트를 놓치거나 시스템이 느려질 수 있다.

#### 재진입 불가능 (Non-Reentrant)

인터럽트 핸들러 실행 중에는 일반적으로 다른 인터럽트가 비활성화된다.
중첩된 인터럽트 처리는 복잡도를 크게 증가시킨다.

#### 컨텍스트 스위칭 비용

인터럽트가 자주 발생하면 상태 저장/복원의 오버헤드가 누적된다.
타이머 인터럽트 주기를 적절히 설정해야 한다.


### 정리
인터럽트는 현대 운영체제의 핵심 메커니즘으로, 이벤트 기반 처리를 가능하게 하여 CPU 효율성을 극대화한다. 

Pintos 프로젝트에서는 타이머 인터럽트를 활용하여 효율적인 Alarm 시스템을 구현할 수 있으며, 이때 동기화 문제를 항상 염두에 두어야 한다.

#### 핵심 개념
- 인터럽트 = 긴급 처리 요청 신호
- 상태 저장 → 처리 → 복원의 3단계
- 공유 자원 접근 시 intr_disable/enable 사용
- 빠르고 간결한 핸들러 작성 필수

## Thread

### 1. 쓰레드의 기본 개념
쓰레드는 "프로세스 내에서 실행되는 작업의 흐름 단위" 또는 **"실행의 최소 단위"**를 의미한다.

- **프로세스(Process)와의 관계**
프로세스는 운영체제로부터 자원(메모리, 파일 등)을 할당받아 실행 중인 프로그램을 의미한다.
하나의 프로세스는 최소 하나의 쓰레드(주로 메인 쓰레드라 불림)를 가지며, 필요에 따라 여러 개의 쓰레드를 가질 수 있다.

**구분** | 회사(프로세스) | 직원(쓰레드)
| :---: | :---: | :---: |
| **특징** | 회사 건물, 자금, 자원 등을 소유한다. | 회사 내에서 실제로 일을 수행하는 주체이며 여러 직원이 함께 일할 수도 있다. |

쓰레드가 여러 개인 프로세스를 **멀티쓰레드 프로세스(Multi-threaded Process)**라고 한다.

### 2. 쓰레드의 구성 요소 및 공유 자원
**구분** | 쓰레드가 독립적으로 가지는 자원 | 쓰레드가 공유하는 자원 (프로세스 단위) |
| :---: | :---: | :---: |
| **쓰레드 식별자** | 쓰레드 ID | 코드 영역 (프로그램 코드) |
| **실행 흐름** | 프로그램 카운터 (PC) | 데이터 영역 (전역 변수, 정적 변수) |
| **CPU 상태** | 레지스터 집합 | 힙 영역 (동적 할당된 메모리) |
| **메모리 영역** | 스택 (Stack) (함수 호출 정보, 지역 변수) | 파일 핸들, 시그널 등 기타 운영체제 자원 |
| **OS 자원** | 스레드 우선순위, 스레드 상태, 스케줄링 정보 등  | 프로세스 ID, 주소 공간, 열린 파일 목록, IPC 자원 등  |

스택을 제외한 프로세스의 대부분의 메모리 공간을 공유하기에, 쓰레드 간의 데이터 교환이 프로세스 간 통신(IPC)보다 훨씬 빠르고 효율적이다. (경량 프로세스라고 불리는 이유)

### 3. 멀티쓰레딩(Multi-threading)

하나의 프로세스 내에서 여러 쓰레드를 동시에 실행하는 것을 **멀티쓰레딩(Multi-threading)**이라고 한다.

#### 응답성 향상 (Responsiveness)

- 사용자 인터페이스(UI)를 담당하는 쓰레드와 시간이 오래 걸리는 작업(예: 네트워크 통신, 파일 처리)을 담당하는 쓰레드를 분리하여, 긴 작업 중에도 UI가 멈추지 않고 사용자 입력에 즉시 반응할 수 있게 한다.

#### 자원 효율성

- 새로운 프로세스를 생성하는 것보다 쓰레드를 생성하는 것이 훨씬 적은 자원을 소모한다.

- 메모리를 공유하기 때문에 프로세스 간 통신보다 데이터 공유가 용이하고 오버헤드가 적다.

#### 멀티코어 활용 (Parallelism)

- CPU가 멀티코어(Multi-core)일 때, 여러 쓰레드를 각각 다른 코어에 할당하여 여러 작업을 동시에(병렬적으로) 처리함으로써 성능을 크게 향상시킬 수 있다.

#### 처리율(Throughput) 증가

- 전체 작업 처리량(단위 시간당 처리하는 작업의 양)이 증가합니다.

### 4. 쓰레드의 문제점 (동기화 문제)
쓰레드가 프로세스의 메모리를 공유하기에, 여러 쓰레드가 공유 데이터에 동시에 접근하여 수정할 때 **경쟁 조건(Race Condition)**이 발생할 수 있다.

#### 경쟁 조건
- 쓰레드의 실행 순서에 따라 결과값이 달라지는 상황.
프로그램의 예측 불가능한 오류가 발생할 수 있으며, 디버깅이 어렵다.

#### 해결책 (동기화 - Synchronization)
- 공유 데이터에 한 번에 하나의 쓰레드만 접근할 수 있도록 상호 배제(Mutual Exclusion) 메커니즘을 사용해야 한다.

- 주요 동기화 기법: 뮤텍스(Mutex), 세마포어(Semaphore), 락(Lock), 모니터(Monitor) 등이 있다.

### 5. 쓰레드 생명 주기 및 Context Switching
#### 쓰레드 생명 주기 (Lifecycle)

- 생성(New) → 실행 가능(Runnable) → 실행(Running) → 대기(Waiting/Blocked) → 종료(Terminated) 등의 단계를 거친다.

#### Context Switching:

- CPU가 현재 실행 중인 쓰레드의 상태(Context)를 저장하고, 다음에 실행할 다른 쓰레드의 상태를 로드하여 실행을 전환하는 작업.

- 멀티쓰레딩 환경에서 CPU 시간을 효율적으로 나누어 쓰레드들이 동시에 실행되는 것처럼 보이게 한다.

- 프로세스 Context Switching보다 쓰레드 Context Switching이 더 가볍고 빠르다 (공유하는 자원이 많기 때문).




# 코드 / 실습

```c
```