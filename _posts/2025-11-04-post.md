---
layout: post
title: "2025-11-04"
date: 2025-11-04 04:00:05 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-11-04)
>오늘은 Week08의 화요일이다 이번 주차부터 웹 서버 제작에 들어간다.

---

## 오늘 한 일
- CSAPP 11.6 공부
- CSAPP 숙제 문제 해결(11.6 - C, 11.7, 11.9, 11.10, 11.11)


---

## TIL
### CSAPP 11.6

네트워크 프로그래밍를 마무리하기 위해 **Tiny**라는 작지만 기능하는 웹 서버를 개발한다.

#### Tiny의 특징

- 프로세스 제어, Unix I/O, 소켓 인터페이스, HTTP 등 많은 내용이 구현되어 있음
- 실제 서버의 기능, 견고성, 보안은 부족하지만 실제 웹 브라우저에 정적 및 동적 콘텐츠를 모두 제공할 수 있음

---

#### main

![](/assets/img/images/2025-11-04-1.png)

```c
#include "csapp.h"

void doit(int fd);
void read_requesthdrs(rio_t *rp);
int parse_uri(char *uri, char *filename, char *cgiargs);
void serve_static(int fd, char *filename, int filesize);
void get_filetype(char *filename, char *filetype);
void serve_dynamic(int fd, char *filename, char *cgiargs);
void clienterror(int fd, char *cause, char *errnum,
                 char *shortmsg, char *longmsg);

int main(int argc, char **argv)
{
    int listenfd, connfd;
    char hostname[MAXLINE], port[MAXLINE];
    socklen_t clientlen;
    struct sockaddr_storage clientaddr;
    
    /* 명령줄 인자 확인 */
    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(1);
    }
    
    listenfd = Open_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(clientaddr);
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        Getnameinfo((SA *) &clientaddr, clientlen, hostname, MAXLINE,
                    port, MAXLINE, 0);
        printf("Accepted connection from (%s, %s)\n", hostname, port);
        doit(connfd);
        Close(connfd);
    }
}
```

#### 동작 방식

Tiny는 **반복 서버(iterative server)**로:

1. 명령줄에 전달된 포트에서 연결 요청 수신 대기
2. `open_listenfd` 함수를 호출하여 수신 소켓 열기
3. 일반적인 무한 서버 루프 진입:
   - 연결 요청 반복적으로 수락 (라인 32)
   - 트랜잭션 수행 (라인 36)
   - 연결 종료 (라인 37)

---

#### doit

![](/assets/img/images/2025-11-04-2.png)

```c
void doit(int fd)
{
    int is_static;
    struct stat sbuf;
    char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];
    char filename[MAXLINE], cgiargs[MAXLINE];
    rio_t rio;
    
    /* 요청 라인과 헤더 읽기 */
    Rio_readinitb(&rio, fd);
    Rio_readlineb(&rio, buf, MAXLINE);
    printf("Request headers:\n");
    printf("%s", buf);
    sscanf(buf, "%s %s %s", method, uri, version);
    if (strcasecmp(method, "GET")) {
        clienterror(fd, method, "501", "Not implemented",
                    "Tiny does not implement this method");
        return;
    }
    read_requesthdrs(&rio);
    
    /* GET 요청에서 URI 파싱 */
    is_static = parse_uri(uri, filename, cgiargs);
    if (stat(filename, &sbuf) < 0) {
        clienterror(fd, filename, "404", "Not found",
                    "Tiny couldn't find this file");
        return;
    }
    
    if (is_static) { /* 정적 콘텐츠 제공 */
        if (!(S_ISREG(sbuf.st_mode)) || !(S_IRUSR & sbuf.st_mode)) {
            clienterror(fd, filename, "403", "Forbidden",
                        "Tiny couldn't read the file");
            return;
        }
        serve_static(fd, filename, sbuf.st_size);
    }
    else { /* 동적 콘텐츠 제공 */
        if (!(S_ISREG(sbuf.st_mode)) || !(S_IXUSR & sbuf.st_mode)) {
            clienterror(fd, filename, "403", "Forbidden",
                        "Tiny couldn't run the CGI program");
            return;
        }
        serve_dynamic(fd, filename, cgiargs);
    }
}
```

#### 기능

`doit` 함수는 하나의 HTTP 트랜잭션을 처리한다.

**프로세스:**

1. **요청 라인 읽기 및 파싱** (라인 11-14)
   - Figure 10.8의 `rio_readlineb` 함수 사용

2. **GET 메소드만 지원** (라인 15-19)
   - 다른 메소드(POST 등) 요청 시 에러 메시지 전송 후 메인 루틴으로 복귀

3. **요청 헤더 읽기** (라인 20)
   - `read_requesthdrs` 호출

4. **URI 파싱** (라인 23)
   - `parse_uri`를 사용하여 파일 이름과 CGI 인자 추출

5. **파일 존재 확인** (라인 24-28)
   - `stat` 함수로 파일 존재 여부 확인
   - 없으면 404 에러 전송

6. **정적 콘텐츠 처리** (라인 30-36)
   - 일반 파일 여부와 읽기 권한 확인 (라인 31)
   - 정적 콘텐츠 제공 (라인 36)

7. **동적 콘텐츠 처리** (라인 38-44)
   - 실행 가능 파일인지 확인 (라인 39)
   - 동적 콘텐츠 제공 (라인 44)

---

#### clienterror

![](/assets/img/images/2025-11-04-3.png)

```c
void clienterror(int fd, char *cause, char *errnum,
                 char *shortmsg, char *longmsg)
{
    char buf[MAXLINE], body[MAXBUF];
    
    /* HTTP 응답 바디 구축 */
    sprintf(body, "<html><title>Tiny Error</title>");
    sprintf(body, "%s<body bgcolor=""ffffff"">\r\n", body);
    sprintf(body, "%s%s: %s\r\n", body, errnum, shortmsg);
    sprintf(body, "%s<p>%s: %s\r\n", body, longmsg, cause);
    sprintf(body, "%s<hr><em>The Tiny Web server</em>\r\n", body);
    
    /* HTTP 응답 출력 */
    sprintf(buf, "HTTP/1.0 %s %s\r\n", errnum, shortmsg);
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-type: text/html\r\n");
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Content-length: %d\r\n\r\n", (int)strlen(body));
    Rio_writen(fd, buf, strlen(buf));
    Rio_writen(fd, body, strlen(body));
}
```

#### 기능

Tiny는 실제 서버에 비해 에러 처리 기능이 부족하지만, 몇 가지 에러를 확인하고 클라이언트에게 보고할 수 있다.

**동작 방식:**

1. **HTTP 응답 바디 구축** (라인 7-11)
   - HTML 형식의 에러 메시지 생성
   - 상태 코드와 상태 메시지 포함
   - 브라우저 사용자에게 에러 설명

2. **응답 헤더와 바디 전송** (라인 14-20)
   - `Content-type`과 `Content-length` 헤더 포함
   - `rio_writen` 함수 사용

**설계 선택:**
- HTML 응답은 바디의 크기와 타입을 나타내야 함
- HTML 콘텐츠를 단일 문자열로 구축하여 크기를 쉽게 결정

---

#### read_requesthdrs

![](/assets/img/images/2025-11-04-4.png)

```c
void read_requesthdrs(rio_t *rp)
{
    char buf[MAXLINE];
    
    Rio_readlineb(rp, buf, MAXLINE);
    while(strcmp(buf, "\r\n")) {
        Rio_readlineb(rp, buf, MAXLINE);
        printf("%s", buf);
    }
    return;
}
```

#### 기능

Tiny는 요청 헤더의 정보를 사용하지 않는다. 단순히 읽고 무시한다.

**동작 방식:**

- 요청 헤더를 종료하는 빈 텍스트 라인은 캐리지 리턴과 라인 피드 쌍으로 구성
- 라인 6에서 이를 확인

---

#### parse_uri

![](/assets/img/images/2025-11-04-5.png)

```c
int parse_uri(char *uri, char *filename, char *cgiargs)
{
    char *ptr;
    
    if (!strstr(uri, "cgi-bin")) {  /* 정적 콘텐츠 */
        strcpy(cgiargs, "");
        strcpy(filename, ".");
        strcat(filename, uri);
        if (uri[strlen(uri)-1] == '/')
            strcat(filename, "home.html");
        return 1;
    }
    else {  /* 동적 콘텐츠 */
        ptr = index(uri, '?');
        if (ptr) {
            strcpy(cgiargs, ptr+1);
            *ptr = '\0';
        }
        else
            strcpy(cgiargs, "");
        strcpy(filename, ".");
        strcat(filename, uri);
        return 0;
    }
}
```

#### Tiny의 가정

- **정적 콘텐츠 홈 디렉토리**: 현재 디렉토리
- **실행 파일 홈 디렉토리**: `./cgi-bin`
- **동적 콘텐츠 판단**: URI에 `cgi-bin` 문자열이 포함되어 있으면 동적 콘텐츠 요청으로 간주
- **기본 파일 이름**: `./home.html`

#### 동작 방식

URI를 파일 이름과 선택적 CGI 인자 문자열로 파싱한다.

**정적 콘텐츠인 경우** (라인 5-12):
1. CGI 인자 문자열 초기화 (라인 6)
2. URI를 `./index.html` 같은 상대 Linux 경로 이름으로 변환 (라인 7-8)
3. URI가 `/` 문자로 끝나면 (라인 9) 기본 파일 이름 추가 (라인 10)

**동적 콘텐츠인 경우** (라인 13-23):
1. CGI 인자 추출 (라인 14-20)
2. URI의 나머지 부분을 상대 Linux 파일 이름으로 변환 (라인 21-22)

---

#### serve_static

![](/assets/img/images/2025-11-04-6.png)

```c
void serve_static(int fd, char *filename, int filesize)
{
    int srcfd;
    char *srcp, filetype[MAXLINE], buf[MAXBUF];
    
    /* 클라이언트에게 응답 헤더 전송 */
    get_filetype(filename, filetype);
    sprintf(buf, "HTTP/1.0 200 OK\r\n");
    sprintf(buf, "%sServer: Tiny Web Server\r\n", buf);
    sprintf(buf, "%sConnection: close\r\n", buf);
    sprintf(buf, "%sContent-length: %d\r\n", buf, filesize);
    sprintf(buf, "%sContent-type: %s\r\n\r\n", buf, filetype);
    Rio_writen(fd, buf, strlen(buf));
    printf("Response headers:\n");
    printf("%s", buf);
    
    /* 클라이언트에게 응답 바디 전송 */
    srcfd = Open(filename, O_RDONLY, 0);
    srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0);
    Close(srcfd);
    Rio_writen(fd, srcp, filesize);
    Munmap(srcp, filesize);
}

/*
 * get_filetype - 파일 이름에서 파일 타입 도출
 */
void get_filetype(char *filename, char *filetype)
{
    if (strstr(filename, ".html"))
        strcpy(filetype, "text/html");
    else if (strstr(filename, ".gif"))
        strcpy(filetype, "image/gif");
    else if (strstr(filename, ".png"))
        strcpy(filetype, "image/png");
    else if (strstr(filename, ".jpg"))
        strcpy(filetype, "image/jpeg");
    else
        strcpy(filetype, "text/plain");
}
```

#### 기능

Tiny는 5가지의 정적 콘텐츠 타입을 제공한다:
- HTML 파일
- 포맷되지 않은 텍스트 파일
- GIF, PNG, JPEG 형식으로 인코딩된 이미지

#### 동작 방식

**1. 응답 헤더 전송** (라인 7-15):
- 파일 이름의 접미사를 검사하여 파일 타입 결정 (라인 7)
- 응답 라인과 응답 헤더를 클라이언트에게 전송 (라인 8-13)
- 빈 라인이 헤더를 종료함을 주의

**2. 응답 바디 전송** (라인 18-22):
- 요청된 파일의 내용을 연결 디스크립터 `fd`로 복사
- **주의 깊게 봐야 할 코드**:
  - 라인 18: `filename`을 읽기용으로 열고 디스크립터 획득
  - 라인 19: Linux `mmap` 함수로 요청된 파일을 가상 메모리 영역에 매핑
    - Section 9.8의 `mmap` 논의 참조
    - `filesize` 바이트의 파일을 주소 `srcp`에서 시작하는 읽기 전용 프라이빗 요구 페이징 가상 메모리 영역에 매핑
  - 라인 20: 파일을 메모리에 매핑한 후 더 이상 디스크립터 필요 없으므로 닫음
  - 라인 21: 메모리 매핑 영역을 클라이언트의 연결 디스크립터로 복사
    - **매우 효율적**: 커널이 매핑 영역을 클라이언트 소켓으로 직접 복사 (추가 복사 오버헤드 없음)
  - 라인 22: 매핑된 가상 메모리 영역 해제
    - **중요**: 잠재적으로 치명적인 메모리 누수 방지

---

#### The serve_dynamic Function

![](/assets/img/images/2025-11-04-7.png)

```c
void serve_dynamic(int fd, char *filename, char *cgiargs)
{
    char buf[MAXLINE], *emptylist[] = { NULL };
    
    /* HTTP 응답의 첫 부분 반환 */
    sprintf(buf, "HTTP/1.0 200 OK\r\n");
    Rio_writen(fd, buf, strlen(buf));
    sprintf(buf, "Server: Tiny Web Server\r\n");
    Rio_writen(fd, buf, strlen(buf));
    
    if (Fork() == 0) {  /* 자식 */
        /* 실제 서버는 여기서 모든 CGI 변수를 설정 */
        setenv("QUERY_STRING", cgiargs, 1);
        Dup2(fd, STDOUT_FILENO);         /* 표준 출력을 클라이언트로 리다이렉트 */
        Execve(filename, emptylist, environ);  /* CGI 프로그램 실행 */
    }
    Wait(NULL);  /* 부모는 자식을 기다리고 회수 */
}
```

#### 기능

Tiny는 자식 프로세스를 포크한 후 자식의 컨텍스트에서 CGI 프로그램을 실행하여 모든 유형의 동적 콘텐츠를 제공한다.

#### 동작 방식

**1. 응답 시작 부분 전송** (라인 6-9):
- 클라이언트에게 성공을 나타내는 응답 라인 전송
- 정보성 Server 헤더 포함
- **주의**: CGI 프로그램이 응답의 나머지 부분을 전송할 책임
- **견고성 부족**: CGI 프로그램이 에러를 만날 가능성을 허용하지 않음

**2. 자식 프로세스 생성 및 CGI 실행** (라인 11-16):
- 새로운 자식 프로세스 포크 (라인 11)
- 자식 프로세스:
  - `QUERY_STRING` 환경 변수를 요청 URI의 CGI 인자로 초기화 (라인 13)
  - **실제 서버는 여기서 모든 CGI 변수를 설정해야 함**
  - `Dup2`로 표준 출력을 클라이언트로 리다이렉트 (라인 14)
  - `Execve`로 CGI 프로그램 실행 (라인 15)

**3. 부모 프로세스** (라인 17):
- 자식 프로세스 종료 대기 및 회수

---

### 핵심 정리

#### Tiny Web Server의 특징
1. 기능하는 웹 서버 구현
2. 한 번에 하나의 클라이언트만 처리
3. GET 메소드만 지원(POST, PUT 등 미지원)
4. 정적/동적 콘텐츠 모두 지원(HTML, 이미지, CGI 프로그램)

#### 주요 함수 흐름
```
main() 
  → Open_listenfd()
  → 무한 루프
    → Accept()
    → doit()
      → read_requesthdrs()
      → parse_uri()
      → stat()
      → serve_static() 또는 serve_dynamic()
    → Close()
```

#### serve_static의 핵심
1. **mmap 사용**: 파일을 가상 메모리에 매핑
2. **효율적 전송**: 커널이 직접 복사 (추가 오버헤드 없음)
3. **메모리 관리**: Munmap으로 메모리 누수 방지

#### serve_dynamic의 핵심
1. **프로세스 제어**: Fork + Execve
2. **환경 변수**: QUERY_STRING 설정
3. **리다이렉션**: Dup2로 표준 출력을 소켓으로 연결
4. **CGI 표준**: 표준 CGI 인터페이스 준수

#### Tiny의 한계
1. **에러 처리 부족**: 기본적인 에러만 처리
2. **반복 서버**: 동시 다중 클라이언트 처리 불가
3. **제한된 메소드**: GET만 지원
4. **보안 기능 없음**: 인증, 권한 검사 미비

## 코드 / 실습
11.6 - C
```c
/* doit함수 안 코드 */
 sscanf(buf, "%s %s %s", method, uri, version);
 printf("===== Parsed Info =====\n");      // 구분선
 printf("Version: %s\n", version); //11.6c HTTP 버전 출력
 printf("=======================\n");      // 구분선
```
11.7
```c
void get_filetype(char *filename, char *filetype) {
    if (strstr(filename, ".html"))
        strcpy(filetype, "text/html");
    else if (strstr(filename, ".gif"))
        strcpy(filetype, "image/gif");
    else if (strstr(filename, ".png"))
        strcpy(filetype, "image/png");
    else if (strstr(filename, ".jpg"))
        strcpy(filetype, "image/jpeg");
/////////////////////////////////////////// 과제 부분
    else if (strstr(filename, ".mpg")) 
        strcpy(filetype, "video/mpeg");
    else if (strstr(filename, ".mp4")) 
        strcpy(filetype, "video/mp4");
///////////////////////////////////////////
    else
        strcpy(filetype, "text/plain");
}
```
나머지 숙제 문제들은 이미 코드안에 완성되어 있다.