---
layout: post
title: "2025-11-15(pintos)"
date: 2025-11-18 11:02:55 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---

# Today's Log(2025-11-15)
>오늘은 Week10의 토요일이다 이번 주차부터 pintos 프로젝트에 들어간다. 
사실 오늘은 공부를 많이 하지 못했다.

---

# 오늘 한 일
- priority-donate-multiple 공부


# TIL
## priority-donate-multiple
Priority Donation(우선순위 기부)은 동기화 문제를 해결하는 핵심 기법이다. 
그중에서도 **Multiple Donation(다중 기부)**은 한 스레드가 여러 자원(Lock)을 점유하고 있을 때 발생하는 우선순위 관리 문제를 다룬다.

### 핵심 역할
가장 기본적인 Priority Donation 즉 우선순위를 빌려주고 다시 돌려 받아야 한다.
여러 개의 lock이 있는 경우를 대비하는 테스트 케이스이다.

### 1. Multiple Donation의 정의
Multiple Donation은 하나의 스레드가 두 개 이상의 Lock을 보유하고 있으며, 각 Lock을 얻기 위해 서로 다른 높은 우선순위의 스레드들이 대기하는 상황을 의미한다.
단일 기부(Single Donation)에서는 단순히 나를 기다리는 스레드의 우선순위를 빌려오면 되지만, 다중 기부 상황에서는 **"누구의 우선순위를, 언제까지 유지해야 하는가"**가 문제의 핵심이 된다.

### 2. 예시

Thread L (우선순위 31): 현재 Lock A와 Lock B를 모두 보유 중이다.
Thread H (우선순위 32): Lock A를 획득하기 위해 L을 대기한다.
Thread M (우선순위 33): Lock B를 획득하기 위해 L을 대기한다.

Thread L은 자신을 기다리는 스레드 중 가장 높은 우선순위인 **33 (Thread M)**을 상속받아야 한다. 
단순히 가장 마지막에 요청한 스레드의 값을 덮어쓰면 안 된다.
만약 Thread L이 Lock B를 해제(Release)한다면 어떻게 되는가?Lock B를 기다리던 Thread M은 락을 획득하고 떠난다.
하지만 Thread L은 여전히 Lock A를 보유 중이며, Thread H가 기다리고 있다.
따라서 Thread L의 우선순위는 원래의 31로 돌아가는 것이 아니라, **남아있는 기부자 중 가장 높은 32 (Thread H)**로 조정되어야 한다.

### 3. 핵심 해결 전략: 기부 목록(Donation List) 관리
단순히 정수형 변수 하나로 현재 기부받은 우선순위를 관리하는 것은 불가능하다. 따라서 thread 구조체 내에 **나에게 기부를 해준 스레드들을 관리하는 리스트(Donation List)**가 필수적으로 요구된다.

나를 기다리는 모든 스레드를 리스트에 저장해야 한다.
리스트에 있는 스레드가 어떤 Lock을 기다리다가 이 리스트에 들어왔는지 식별할 수 있어야 한다.
이는 추후 특정 Lock 해제 시 해당 스레드만 리스트에서 제거하기 위함이다.
기부 상황이 모두 종료되었을 때 복귀할 True_priority를 별도로 저장하고 있어야 한다.

### 4. 단계별 동작 메커니즘
Multiple Donation을 처리하는 로직은 크게 Lock Acquire 시점과 Lock Release 시점으로 나뉜다.

#### A. Lock Acquire
어떤 스레드(기부자)가 이미 점유된 Lock을 요청할 때 다음 과정이 수행된다.

Lock의 현재 소유자(수혜자)의 donations 리스트에 요청 스레드를 추가한다.
소유자는 리스트에 있는 모든 스레드의 우선순위와 자신의 True_priority를 비교하여, 그중 **최댓값**으로 자신의 현재 우선순위를 갱신한다.

### B. Lock Release
Lock 소유자가 자원을 반납할 때가 가장 중요한 순간이다. 
단순히 기부받은 값을 초기화해서는 안 된다.

해제하려는 **'해당 Lock'**을 기다리던 스레드들을 donations 리스트에서 찾아 모두 제거한다. 
다른 Lock을 기다리는 스레드는 리스트에 남겨둬야 한다.
우선순위 재평가 : 스레드 제거 후 리스트가 비어 있다면 **True_priority**로 복구한다.
리스트에 아직 스레드가 남아 있다면 **남은 스레드 중 가장 높은 우선순위**를 찾아 현재 우선순위로 설정한다.

### 5. 결론
Multiple Donation 구현의 핵심은 관리다.

단순 값 변경이 아닌, 리스트를 활용하여 기부자들을 관리해야 한다.

Lock 해제 시, 전체 초기화가 아닌 관련된 기부자만 선별적으로 제외해야 한다.
상태 변경 시마다 남아있는 기부자들 중 최댓값을 다시 계산하여 적용해야 한다.


# 코드 / 실습
```c
```