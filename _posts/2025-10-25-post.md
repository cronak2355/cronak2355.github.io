---
layout: post
title: "2025-10-25"
date: 2025-10-26 03:19:17 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-10-25)
>오늘은 Week07의 주말 첫 날이다. 오늘은 매크로 함수를 이해하면서 malloc lab 구현의 기초를 닦기로 하였다.

---

## 오늘 한 일
- malloc lab 매크로 공부 

---

## TIL
### **매크로**
기본 상수
```c
#define WSIZE 4              // Word size (Header/Footer 크기)
#define DSIZE 8              // Double word (정렬 요구사항)
#define CHUNKSIZE (1<<12)    // 힙 확장 크기 (4KB)
```
비트 연산
```c
#define PACK(size, alloc) ((size) | (alloc))     // 크기+할당비트 합치기
#define GET_SIZE(p) (GET(p) & ~0x7)              // 크기만 추출
#define GET_ALLOC(p) (GET(p) & 0x1)              // 할당 여부만 추출
```
메모리 접근
```c
#define GET(p) (*(unsigned int *)(p))            // 4바이트 읽기
#define PUT(p, val) (*(unsigned int *)(p) = (val))  // 4바이트 쓰기
```
블록 포인터 계산
```c
#define HDRP(bp) ((char *)(bp) - WSIZE)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)))
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE((char *)(bp) - DSIZE))
```

### **비트 연산**
```c
Header = PACK(32, 1) = 33 (이진수: 100001)
GET_SIZE = 33 & ~0x7 = 32 (이진수: 100000)
//→ 하위 3비트를 제거해서 할당 비트를 없앤다
```
& ~0x7: 하위 3비트를 0으로 하는데 이유가 있다.

최적화를 위해서 블록을 8바이트 기준으로 정렬하는데 8바이트 정렬이므로 
하위 3비트는 정렬에 방해 됨을 알 수 있다. 

예를 들어 4, 2, 1이 섞여있을경우 8바이트 정렬이 무너질 수 있고
그렇기에 하위 3비트를 0으로 정렬하는 것이다.  

또한 이 나머지 3비트는 나중에 플래그로 사용하는데 GET_SIZE를 사용해 크기를 얻어야 할때는 이러한 3비트가 있으면 정렬이 깨끗하게 되지 않기 때문에 초기화 해주는 것이다.

& 0x1: 최하위 1비트만 추출한다.
이 설명이 하위 3비트를 0으로 하는 이유를 또 한번 증명한다.
하위 3비트는 8바이트 정렬로 할 때 사용하지 않는 비트가 되고 우리는 이걸 영리하게 사용할 수 있다. 
사용하지 않는 비트를 플래그로 이용하는 것이다.
주소가 할당되었는지 혹은 할당되지 않았는지를 사용하지 않는 비트를 활용해서 판별할 수 있는 것이다. 



8바이트 정렬이므로 크기는 항상 8의 배수 → 하위 3비트는 항상 0


### **포인터 연산**

FTRP(bp) 계산하기
bp = 0x2004
GET_SIZE(HDRP(bp)) = 48

```c
FTRP(bp) = ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
         = 0x2004 + 48 - 8

= (0x2004 + 48) - 8
= 0x2044 - 8
= 0x203C

```
포인터 연산을 할때는 단위를 맞추는 것을 항상 중요하게 생각해야 한다.
0x2004 + 48은 모르고 계산 할 경우 0x2052라는 결과를 도출해버릴 수도 있다.

그렇기에 알아보자면 주소는 16진수이니 우리는 포인터 연산을 16진수 기준으로 계산해야한다.
48을 16진수로 환산하면 우선 48은 16^1 보다 크므로 16으로 나눠주면 48/16 = 3 고로 0x0030이다.

이제 더해주면 0x2004 + 0x0030 = 0x2034로 결과를 도출 할 수 있다.
하지만 계산이 끝난 것이 아니다 이제 8을 더하면 진짜 결과를 얻어낼 수 있다.
8은 0x0008로 표기할 수 있다. 그러나 0x2034 - 0x0008은 16진수 연산이라는 것을 유의하여야 한다.

우선 0x0004 - 0x0008은 할 수 없으므로 우리는 16^1부분에서 16을 빌려와야 한다.
고로 우리는 0x2034에서 3 부분을 2로 만들고 20-8식의 연산을 실행 할 수 있다.
(0x0010은 16이고 0x0004은 4,  16+4 = 20이다) 20 - 8 = 12
12는 16진수에서 C로 표현한다. 
고로 정답은 0x202C이다.


### **포인터 이동**

```c
HDRP(bp) = ((char *)(bp) - WSIZE)
bp = 0x2004

(char *)(0x2004) - 4 = 0x2000  // 주소 이동!

int *ptr + 1    // 4바이트 이동
char *ptr + 1   // 1바이트 이동

```
포인터 이동을 할때 자료형의 크기만큼 이동한다. 
malloc lab은 정확히 N바이트만큼 이동하기 위해(char *)로 캐스팅한다.

---

### **매크로 중첩**

다음 블록이 할당되었는지 확인
GET_ALLOC(NEXT_BLKP(HDRP(bp))) => 헤더의 다음 블록의 할당 여부 => 말이 안됌

GET_ALLOC(HDRP(NEXT_BLKP(bp))) => 다음 블록의 헤더의 할당 여부 => 바람직함

패턴 정리:
// bp로 시작할 때는 항상 HDRP로 감싸기!
GET_SIZE(HDRP(bp))
GET_ALLOC(HDRP(bp))
GET_SIZE(HDRP(NEXT_BLKP(bp)))
GET_ALLOC(HDRP(PREV_BLKP(bp)))

---

### **핵심 블록 구조**
```
[Header(4)] [Payload(n)] [Footer(4)]
    ↑           ↑            ↑
 HDRP(bp)      bp        FTRP(bp)
```
```
이전 블록                    현재 블록
[Header][Payload][Footer] [Header][Payload]
                   ↑                  ↑
              bp - DSIZE             bp
              (Footer 위치)
```
---

## 코드 / 실습
```c
/* Basic constants and macros */
#define WSIZE 4        /* Word and header/footer size (bytes) */ 
                       /* 워드 크기 = 4바이트. Header와 Footer의 크기 */
                       
#define DSIZE 8        /* Double word size (bytes) */ 
                       /* 더블 워드 크기 = 8바이트. 정렬(alignment) 요구사항 */
                       
#define CHUNKSIZE (1<<12)  /* Extend heap by this amount (bytes) */
                           /* 힙을 확장할 때 요청할 크기 = 4096바이트 = 4KB */

#define MAX(x,y) ((x)>(y)?(x):(y))
/* 두 값 중 큰 값을 반환하는 매크로 */

/* Pack a size and allocated bit into a word */
#define PACK(size,alloc) ((size)|(alloc))
/* 크기(size)와 할당 여부(alloc)를 하나의 워드로 합침 
   예: PACK(16, 1) = 17 (크기 16, 할당됨) 
   size의 하위 3비트는 항상 0이므로 (8바이트 정렬), 
   alloc(0 또는 1)과 OR 연산 가능 */

/* Read and write a word at address p */
#define GET(p) (*(unsigned int*)(p))
/* 주소 p에 있는 값을 읽어옴 (4바이트를 unsigned int로 읽음) */

#define PUT(p,val) (*(unsigned int*)(p)=(val))
/* 주소 p에 값 val을 씀 (4바이트를 unsigned int로 씀) */

/* Read the size and allocated fields from address p */
#define GET_SIZE(p) (GET(p)&~0x7)
/* 주소 p에서 블록 크기를 읽어옴 
   &~0x7 = 하위 3비트를 0으로 만듦 (할당 비트 제거)
   예: 17(10001) & ~0x7(11000) = 16(10000) */

#define GET_ALLOC(p) (GET(p)&0x1)
/* 주소 p에서 할당 여부를 읽어옴 
   &0x1 = 최하위 1비트만 추출
   0 = free, 1 = allocated */

/* Given block ptr bp, compute address of its header and footer */
#define HDRP(bp) ((char*)(bp)-WSIZE)
/* 블록 포인터 bp가 주어졌을 때, 해당 블록의 header 주소 계산
   bp는 payload의 시작 주소를 가리키므로, 
   header는 그 앞(WSIZE = 4바이트)에 위치 */

#define FTRP(bp) ((char*)(bp)+GET_SIZE(HDRP(bp))-DSIZE)
/* 블록 포인터 bp가 주어졌을 때, 해당 블록의 footer 주소 계산
   1. HDRP(bp)로 header 주소 구함
   2. GET_SIZE()로 블록 전체 크기 구함
   3. bp + 블록크기 - DSIZE(8) = footer 위치
   (블록크기는 header+payload+footer 포함, 
    DSIZE를 빼는 이유는 header(4) + footer(4) = 8바이트) */

/* Given block ptr bp, compute address of next and previous blocks */
#define NEXT_BLKP(bp) ((char*)(bp)+GET_SIZE(((char*)(bp)-WSIZE)))
/* 다음 블록의 bp(payload 시작 주소)를 계산
   1. (bp - WSIZE)로 현재 블록의 header 주소 구함
   2. GET_SIZE()로 현재 블록의 크기 구함
   3. bp + 현재블록크기 = 다음 블록의 bp */

#define PREV_BLKP(bp) ((char*)(bp)-GET_SIZE(((char*)(bp)-DSIZE)))
/* 이전 블록의 bp(payload 시작 주소)를 계산
   1. (bp - DSIZE)로 이전 블록의 footer 주소 구함
   2. GET_SIZE()로 이전 블록의 크기 구함
   3. bp - 이전블록크기 = 이전 블록의 bp */


```

