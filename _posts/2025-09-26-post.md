---
layout: post
title: "2025-09-26"
date: 2025-09-27 03:01:36 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
오늘은 Week04 두번째날이다.
어제 코딩테스트에서 한 문제도 못 풀었던 충격에서 벗어나 새로운 공부 방법으로 접근한 첫날이었다. 시간표를 짜고 책과 문제 풀이를 병행하며, 일정 시간 고민 후 풀리지 않으면 정답을 보는 방식을 적용했다. 그리고 오늘은 동료와 함께 문제를 풀었는데 충격적일만큼 효율적이였다! 혼자 문제 푸는 것보다 빨리 풀어질 뿐더러 생각이 확장되는 것을 느꼈다. 
이번에는 11047, 1541, 1931번 문제를 풀며 느낀 점을 간단히 정리해보고자 한다. 
아래 모든 내용은 Python 기준으로 작성되었다.

11047번 문제에서는
동전 0 문제로, 그리디 알고리즘의 가장 기본적인 유형이었다.
큰 동전부터 사용하여 최소 개수를 구하는 방식이 직관적이고 명확했다. coin.sort(reverse=True)로 내림차순 정렬 후, 각 동전에 대해 몫과 나머지를 활용하는 방식으로 구현했다.
이 문제를 통해 그리디 알고리즘의 핵심인 "매 순간 최선의 선택"이 전체 최적해를 보장하는 경우를 이해할 수 있었고, 동전 문제에서는 큰 단위부터 사용하는 것이 항상 최적이라는 것을 확인했다.

1541번 문제에서는
잃어버린 괄호 문제로, 처음에는 어떻게 접근해야 할지 막막했다.
하지만 문제를 다시 읽어보니 최솟값을 만들려면 빼기 뒤에 오는 모든 수를 최대한 크게 만들면 된다는 것을 깨달았다. - 기호로 split한 후, 각 부분에서 +로 연결된 수들을 모두 더해주는 방식으로 접근했다.
이 문제를 통해 그리디 문제도 단순히 공식을 외우는 것이 아니라, 문제의 본질을 파악하는 것이 중요하다는 걸 느꼈다. 수식을 어떻게 해석하느냐가 핵심이었다.

1931번 문제에서는
회의실 배정 문제로, 가장 어려웠던 문제였다. 그리고 동료 학습을 진행한 문제이기도 하다.
처음에는 시작 시간 기준으로 정렬해야 하나 고민했지만, 결국 끝나는 시간을 우선으로 정렬해야 한다는 것을 깨달았다. cmp_to_key를 사용해서 끝나는 시간 기준으로 정렬하되, 끝나는 시간이 같으면 시작 시간 기준으로 정렬하도록 구현했다.
이 문제에서 그리디의 핵심을 다시 한번 느낄 수 있었다. 전체를 보지 않고 매 순간 최선의 선택(가장 빨리 끝나는 회의)을 하는 것이 전체 최적해를 만든다는 것이 신기했다. 또한 동료 학습의 중요성 또한 알게 되었다. 2시간도 안되서 문제를 풀어냈음에도 불구하고 완벽히 문제가 이해가 되고 또한 사고가 혼자 하는 것보다 확장되는 것을 느꼈다. 앞으로 동료 학습을 많이 해야 겠다.

이렇게 정글에서의 Week04 둘째날이 끝이 났다.
어제의 좌절에서 벗어나 새로운 방법으로 접근하니 확실히 문제에 대한 이해도가 높아진 것을 느꼈다. 그리디 알고리즘의 기본기를 다질 수 있었고, 앞으로도 이런 식으로 꾸준히 해나가면 실력이 늘 것 같다는 자신감이 생겼다.
나의 일을 하자.
-마침-

