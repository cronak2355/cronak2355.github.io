---
layout: post
title: "2025-10-28"
date: 2025-10-29 16:22:46 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-10-28)
>오늘은 Week07의 화요일이다 implicit free list을 모두 구현하였다.

---

## 오늘 한 일
- malloc lab의 implicit free list을 모두 구현하였다.

---

## TIL
### **Free**
Free는 단순히 할당여부를 0으로 만들어주면 되는 일이기에
현재 블록의 size를 받고 그 size 기준으로 header와 footer의 할당 여부를 0으로 해주면 된다.

### **Coalesce**
4가지 케이스가 존재하며 각 케이스를 살펴보겠다.

전 블록과 다음 블록이 모두 할당된 경우 : 
이럴 경우 합칠 블록이 없으므로 그냥 현재 블록의 주소를 반환해주면 된다.

전 블록은 할당되었고 다음 블록은 할당되지 않은 경우 : 
이런 경우 현재 블록과 다음 블록의 사이즈를 합친 후
header와 footer에 할당해주면 된다.

전 블록이 할당되지 않았고 다음 블록이 할당되어 있는 경우 : 
이런 경우 전 블록과 현재 블록의 사이즈를 합친 후 
전 블록의 주소 기준으로 header와 footer을 할당해주면 된다.

전 블록과 다음 블록이 모두 할당되지 않은 경우 : 
이럴 경우 모든 블록의 사이즈를 합친 후
header와 footer을 할당해주면 된다.

해당 되는 경우가 없을 경우 그냥 현재 블록의 주소를 반환한다. 

---

## 코드 / 실습
Free
```c
void mm_free(void *ptr)
{
    if(ptr == NULL) { //ptr이 NULL일 경우 Return
        return;
    }

    size_t size = GET_SIZE(HDRP(ptr)); // 현재 블록의 크기를 저장

    PUT(HDRP(ptr), PACK(size, 0)); //현재 header의 주소에 크기와 할당 여부를 넣음
    PUT(FTRP(ptr), PACK(size, 0)); //현재 footer의 주소에 크기와 할당 여부를 넣음

    coalesce(ptr);
}

```
Coalesce
```c
void *coalesce(void *ptr) {
    size_t size;
    size_t size_prev = GET_SIZE(FTRP(PREV_BLKP(ptr)));
    size_t size_now = GET_SIZE(HDRP(ptr));
    size_t size_next = GET_SIZE(HDRP(NEXT_BLKP(ptr)));

    size_t alloc_prev = GET_ALLOC(FTRP(PREV_BLKP(ptr)));
    size_t alloc_now = GET_ALLOC(HDRP(ptr));
    size_t alloc_next = GET_ALLOC(HDRP(NEXT_BLKP(ptr)));

   if(alloc_prev == 1 && alloc_next == 1) {   // 합칠 게 없음
        return ptr;
    }
    else if(alloc_prev == 1 && alloc_next == 0) { //전 블록이 allocated이고 다음 블록이 free인 경우
        size = size_now + size_next; //현재 블록과 다음 블록의 사이즈를 합침
        PUT(HDRP(ptr), PACK(size, 0)); //필요한 만큼 할당
        PUT(FTRP(ptr), PACK(size, 0)); //필요한 만큼 할당
        return ptr;
    }
    else if(alloc_prev == 0 && alloc_next == 1) { //전 블록이 free이고 다음 블록이 allocated인 경우
        size = size_prev + size_now; //전 블록과 현재 블록의 사이즈를 합침
        PUT(HDRP(PREV_BLKP(ptr)), PACK(size, 0)); //필요한 만큼 할당
        PUT(FTRP(ptr), PACK(size, 0)); //필요한 만큼 할당
        return PREV_BLKP(ptr);
    }
    else  { //해당되는 경우가 없을 경우
        size = size_prev + size_now + size_next; // 모두 합침
        PUT(HDRP(PREV_BLKP(ptr)), PACK(size, 0)); //필요한 만큼 할당
        PUT(FTRP(NEXT_BLKP(ptr)), PACK(size, 0)); //필요한 만큼 할당
        return PREV_BLKP(ptr);
    }
    return ptr;
}

}
```

