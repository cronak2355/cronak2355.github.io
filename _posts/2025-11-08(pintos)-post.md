---
layout: post
title: "2025-11-08(pintos)"
date: 2025-11-10 13:46:33 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-11-07)
>오늘은 Week09의 발제날이다 이번 주차부터 pintos 프로젝트에 들어간다.

---

# 오늘 한 일
- timer.c 공부

---

# TIL
## Timer
Timer 문제를 계속해서 풀고 있는데, 상당히 어려운 과정을 밟고 있다.
지금까지 이해한 것에 대해서만 간략하게 써보려 한다.

우선 현재 Timer 문제에서 요구하는 것은 busy waiting 문제를 해결하는 것이다. 

### busy waiting
busy waiting 이란 CPU를 점유한 채 특정 조건을 반복적으로 검사하며 CPU 시간을 낭비하는 것이다.

현재 ready_list 즉 스케줄러에 의해 정리되어 사용될 순서가 정해지고 사용되어지기 위해 기다리고 있는 리스트가 있고
A, B, C, D 쓰레드들이 안에 존재 한다 가정해보자

CPU가 A 쓰레드를 보았을 때 A 쓰레드가 현재 필요하지 않은 상황이라 판단하여 A 쓰레드를 사용하지 않으려 한다. 

현재 기본적인 핀토스 코드는 A 쓰레드가 CPU를 점거하며 필요해질 때까지 A 대신 B, A 대신 C, A 대신 D 이런 식으로 **"양보"**하는 방식으로 사용 된다.

이러한 것을 busy waiting이라 부르며 말 그대로 A가 사용 될 때까지 기다리지만 왔다갔다 양보하면서 바쁘게 기다린다. 

이러한 방식은 비효율적이며 그렇기에 우리는 이것을 바꿔줘야 한다.
많은 방식으로 바꿀 수 있지만 필자는 정석이라 할 수 있는 **Block** 방식으로 바꾸려 한다.

### Block
Block 방식이란 busy waiting 즉 바쁜 기다림을 바쁘지 않게 바꿔주는 것이다. 

자리를 맡아주는 느낌이라 생각하면 편할 것이다. 

busy waiting에서 우리는 
A 쓰레드가 필요해질 때까지 A 대신 B, A 대신 C, A 대신 D 이런 식으로 양보하는 방식으로 사용 되는 것을 보았다. 

우리는 이것을 하나하나 양보하는 것이 아닌 자리를 맡아주는 식으로 바꿔줄 것이.

예시를 들어보겠다.

A, B, C, D 쓰레드가 있다 가정해보자
CPU는 A 쓰레드가 현재는 필요 없고 일정 시간(혹은 다른 것)후에 필요할 것이라 판단했다. 
그러한 일정 시간이 진행될 것우 B, C, A, D 순서대로 쓰레드가 실행된다 가정해보자

이럴 경우 A를 일정 시간 동안잠시 다른 곳으로 뺀다. 
그럼 리스트는 B, C, D가 될 것이고 B, C 순차적으로 실행된다. 
그 후 다시 A가 리스트에 들어와 A, D가 되어 정상적으로 실행된다.
이것이 Block 이다.

### 어떻게 구현하려 하는가?
우선 깨어나야할 시간을 확보 한다.
그 후 현재의 쓰레드를 변수로 저장하고
함수를 통해 스레드를 재운다.
깨어나야할 시간은 쓰레드 구조체를 통해서 리스트에 넣고
깨어나야할 시간 기준으로 정렬을 한다.
깨어나야할 시간이 되면 깨워준다.





# 코드 / 실습

```c
```