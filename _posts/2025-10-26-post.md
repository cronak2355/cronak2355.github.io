---
layout: post
title: "2025-10-26"
date: 2025-10-27 03:01:44 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-10-26)
>오늘은 Week07의 일요일이다. 오늘은 매크로 함수를 이해하면서 malloc lab 
mm_init을 구현하기로 하였다.
---

## 오늘 한 일
- malloc lab mm_init 구현

---

## TIL
### **heap 메모리 구조**
Header(헤더)는 블록의 가장 앞부분에 위치하며, 해당 블록을 관리하는 데 필수적인 메타데이터(Metadata)를 저장한다.

크기는 4바이트(WSIZE)이며 블록의 전체 크기와 할당 플래그를 저장한다.
이 블록이 총 몇 바이트인지, 현재 사용 중인지를 알려준다.

할당기가 힙을 순회할 때, 블록의 경계와 상태를 빠르게 파악하여 다음 블록으로 이동하거나 병합(Coalescing)할지 결정하는 데 사용된다.

Payload(페이로드)는 Header 바로 뒤에 위치하며, 사용자(프로그램)가 실제로 데이터를 저장하는 공간이다.

사용자가 malloc으로 요청한 정렬(Alignment) 요구 사항을 맞춰 크기가 확장된다.

malloc함수가 사용자에게 반환하는 주소(bp, 블록 포인터)가 바로 이 Payload의 시작 주소이다.
사용자는 이 공간에 자신의 데이터를 저장한다.

Footer(푸터)는 블록의 가장 끝부분에 위치하며, Header와 동일한 정보를 저장하는 경우가 많다.

4바이트(WSIZE) 크기이며 블록의 크기 및 할당 플래그(Header와 동일)를 저장한다.

주로 이전 블록을 합칠 때(Backward Coalescing)사용된다. 
현재 블록의 bp만 가지고도 Footer의 주소를 계산하고, Footer를 통해 이전 블록의 크기를 알 수 있어 메모리 합치기 작업을 용이하게 한다.

Footer가 존재하는 방식(Header + Payload + Footer)을 사용하는 것을 경계 태그(Boundary Tag) 방식이라고 한다.
### **mm_init**
우선 비어있는 힙을 생성해 준다.
그 후 header와 footer 그리고 그 다음에 올 header 또한 설정해 준다
그 후 첫 번째 블록 위치를 설정해 준다.

---

## 코드 / 실습
```c
int mm_init(void) 
{
    
    if ((heap_listp = mem_sbrk(4*WSIZE)) == (void *)-1) // 초기 빈 힙 생성 (16바이트 할당)
        return -1;  // 힙 확장 실패 시 -1 반환
    
   
    PUT(heap_listp, 0);                            // Padding: 8바이트 정렬을 위한 더미 워드
    PUT(heap_listp + (1*WSIZE), PACK(DSIZE, 1));  // Prologue Header: 8바이트, allocated
    PUT(heap_listp + (2*WSIZE), PACK(DSIZE, 1));  // Prologue Footer: 8바이트, allocated  
    PUT(heap_listp + (3*WSIZE), PACK(0, 1));      // Epilogue Header: 0바이트, allocated
    
    
    heap_listp += (2*WSIZE);	// heap_listp를 첫 번째 가용 블록 위치로 이동 (Prologue 다음)
    
    return 0;  // 초기화 성공
}

```

