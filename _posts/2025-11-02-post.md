---
layout: post
title: "2025-11-02"
date: 2025-11-02 01:49:05 +0900
categories: [KRAFTON JUNGLE]
tags: [Programming]
---
---


# Today's Log(2025-11-02)
>오늘은 Week08의 일요일이다 이번 주차부터 웹 서버 제작에 들어간다.

---

## 오늘 한 일
- CSAPP 11.4.7~11.4.9 공부

---

## TIL
### CSAPP 11.4.7

Linux는 바이너리 소켓 주소 구조체와 호스트 이름, 호스트 주소, 서비스 이름, 포트 번호의 문자열 표현 간 변환을 위한 강력한 함수들을 제공한다: `getaddrinfo`와 `getnameinfo`.

소켓 인터페이스와 함께 사용하면 특정 IP 프로토콜 버전에 독립적인 네트워크 프로그램을 작성할 수 있다.

 

#### The getaddrinfo Function

##### 함수 시그니처
```c
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

int getaddrinfo(const char *host, const char *service,
                const struct addrinfo *hints,
                struct addrinfo **result);
// 반환: 성공 시 0, 오류 시 0이 아닌 에러 코드

void freeaddrinfo(struct addrinfo *result);
// 반환: 없음

const char *gai_strerror(int errcode);
// 반환: 에러 메시지 문자열
```

##### 기능

호스트 이름, 호스트 주소, 서비스 이름, 포트 번호의 문자열 표현을 소켓 주소 구조체로 변환한다.

##### 특징

- `gethostbyname`과 `getservbyname` 함수의 대체품
- **재진입 가능(reentrant)**: 멀티스레드 환경에서 안전
- **프로토콜 독립적**: 모든 프로토콜에서 작동

##### addrinfo 구조체

![](/assets/img/images/2025-11-02-1.png)


!![](/assets/img/images/2025-11-02-2.png)

```c
struct addrinfo {
    int ai_flags;              /* 힌트 인자 */
    int ai_family;             /* 첫 번째 인자: AF_INET, AF_INET6 */
    int ai_socktype;           /* 두 번째 인자: SOCK_STREAM, SOCK_DGRAM */
    int ai_protocol;           /* 세 번째 인자: 보통 0 */
    char *ai_canonname;        /* 정식 호스트 이름 */
    size_t ai_addrlen;         /* ai_addr 구조체의 크기 */
    struct sockaddr *ai_addr;  /* 소켓 주소 구조체 포인터 */
    struct addrinfo *ai_next;  /* 연결 리스트의 다음 항목 포인터 */
};
```

##### 동작 방식

1. `host`와 `service` (소켓 주소의 두 구성 요소)가 주어지면
2. `getaddrinfo`는 `addrinfo` 구조체의 연결 리스트를 가리키는 `result`를 반환
3. 각 구조체는 `host`와 `service`에 해당하는 소켓 주소 구조체를 가리킴

##### 파라미터 설정

**host 인자:**
- 도메인 이름 또는 숫자 주소 (점-십진 IP 주소)
- 호스트 이름을 주소로 변환하지 않으려면 NULL 설정 가능

**service 인자:**
- 서비스 이름 (예: http) 또는 십진 포트 번호
- NULL 설정 가능
- **중요**: host와 service 중 최소 하나는 반드시 지정해야 함

**hints 인자 (선택적):**
- `addrinfo` 구조체로, `getaddrinfo`가 반환하는 소켓 주소 리스트를 세밀하게 제어
- `ai_family`, `ai_socktype`, `ai_protocol`, `ai_flags` 필드만 설정 가능
- 나머지 필드는 0 (또는 NULL)로 설정
- 실전에서는 `memset`으로 전체 구조체를 0으로 초기화한 후 선택적으로 필드 설정

##### 주요 hints 필드

**ai_family:**
- 기본값: IPv4와 IPv6 소켓 주소 모두 반환
- `AF_INET`: IPv4 주소로만 제한
- `AF_INET6`: IPv6 주소로만 제한

**ai_socktype:**
- 기본값: 각 고유 주소에 대해 최대 3개의 addrinfo 구조체 반환 (연결용, 데이터그램용, raw 소켓용)
- `SOCK_STREAM`: 연결의 끝점으로 사용할 수 있는 소켓 주소에 대해 최대 1개의 구조체로 제한

**ai_flags:**
여러 값을 OR 연산으로 조합하여 비트 마스크 생성

- **AI_ADDRCONFIG**: 
  - 연결 사용 시 권장
  - 로컬 호스트가 IPv4로 구성된 경우에만 IPv4 주소 반환 (IPv6도 마찬가지)

- **AI_CANONNAME**: 
  - 기본적으로 `ai_canonname` 필드는 NULL
  - 이 플래그 설정 시, 리스트의 첫 번째 addrinfo 구조체의 `ai_canonname` 필드가 host의 정식(공식) 이름을 가리킴

- **AI_NUMERICSERV**: 
  - 기본적으로 service 인자는 서비스 이름 또는 포트 번호 가능
  - 이 플래그는 service 인자를 포트 번호로 강제

- **AI_PASSIVE**: 
  - 기본적으로 `getaddrinfo`는 클라이언트가 능동 소켓으로 `connect` 호출에 사용할 소켓 주소 반환
  - 이 플래그는 서버가 수신 소켓으로 사용할 소켓 주소 반환
  - 이 경우 host 인자는 NULL이어야 함
  - 결과 소켓 주소 구조체의 주소 필드는 와일드카드 주소가 됨
  - 커널에게 이 서버가 이 호스트의 모든 IP 주소로의 요청을 수락할 것임을 알림

##### 사용 후 처리

- 클라이언트: 리스트를 순회하며 `socket`과 `connect`가 성공할 때까지 각 소켓 주소 시도
- 서버: 리스트를 순회하며 `socket`과 `bind`가 성공할 때까지 각 소켓 주소 시도
- **메모리 누수 방지**: 애플리케이션은 `freeaddrinfo` 호출하여 리스트 해제 필수
- **에러 처리**: 0이 아닌 에러 코드 반환 시, `gai_strerror`로 메시지 문자열로 변환 가능

##### 강력한 특성

`getaddrinfo`가 반환하는 `addrinfo` 구조체의 인자들은 애플리케이션의 추가 조작 없이 소켓 인터페이스 함수에 직접 전달 가능:

- `ai_family`, `ai_socktype`, `ai_protocol` → `socket()`에 직접 전달
- `ai_addr`, `ai_addrlen` → `connect()`, `bind()`에 직접 전달

이 강력한 속성 덕분에 특정 IP 프로토콜 버전에 독립적인 클라이언트와 서버 작성 가능!

---

#### The getnameinfo Function

##### 함수 시그니처
```c
#include <sys/socket.h>
#include <netdb.h>

int getnameinfo(const struct sockaddr *sa, socklen_t salen,
                char *host, size_t hostlen,
                char *service, size_t servlen, int flags);
// 반환: 성공 시 0, 오류 시 0이 아닌 에러 코드
```

##### 기능

`getaddrinfo`의 역함수로, 소켓 주소 구조체를 해당하는 호스트와 서비스 이름 문자열로 변환한다.

##### 특징

- 구식 `gethostbyaddr`과 `getservbyport` 함수의 현대적 대체품
- **재진입 가능(reentrant)**
- **프로토콜 독립적**

##### 파라미터

- `sa`: `salen` 바이트 크기의 소켓 주소 구조체 포인터
- `host`: `hostlen` 바이트 크기의 버퍼 포인터
- `service`: `servlen` 바이트 크기의 버퍼 포인터

##### 동작 방식

1. 소켓 주소 구조체 `sa`를 해당하는 호스트와 서비스 이름 문자열로 변환
2. `host`와 `service` 버퍼에 복사
3. 0이 아닌 에러 코드 반환 시, `gai_strerror`로 문자열 변환 가능

##### 선택적 파라미터

- 호스트 이름이 필요 없으면: `host`를 NULL, `hostlen`을 0으로 설정
- 서비스 필드도 동일
- **중요**: 둘 중 하나는 반드시 설정해야 함

##### flags 인자

기본 동작을 수정하는 비트 마스크:

- **NI_NUMERICHOST**: 
  - 기본적으로 `getnameinfo`는 `host`에 도메인 이름 반환 시도
  - 이 플래그 설정 시 숫자 주소 문자열 반환

- **NI_NUMERICSERV**: 
  - 기본적으로 `getnameinfo`는 `/etc/services` 조회하여 가능하면 포트 번호 대신 서비스 이름 반환
  - 이 플래그는 조회를 건너뛰고 단순히 포트 번호만 반환

---

#### hostinfo 예제 프로그램

![](/assets/img/images/2025-11-02-3.png)

```c
#include "csapp.h"

int main(int argc, char **argv)
{
    struct addrinfo *p, *listp, hints;
    char buf[MAXLINE];
    int rc, flags;
    
    if (argc != 2) {
        fprintf(stderr, "usage: %s <domain name>\n", argv[0]);
        exit(0);
    }
    
    /* addrinfo 레코드 리스트 획득 */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_INET;       /* IPv4만 */
    hints.ai_socktype = SOCK_STREAM; /* 연결만 */
    if ((rc = getaddrinfo(argv[1], NULL, &hints, &listp)) != 0) {
        fprintf(stderr, "getaddrinfo error: %s\n", gai_strerror(rc));
        exit(1);
    }
    
    /* 리스트를 순회하며 각 IP 주소 출력 */
    flags = NI_NUMERICHOST; /* 도메인 이름 대신 주소 문자열 출력 */
    for (p = listp; p; p = p->ai_next) {
        Getnameinfo(p->ai_addr, p->ai_addrlen, buf, MAXLINE, NULL, 0, flags);
        printf("%s\n", buf);
    }
    
    /* 정리 */
    Freeaddrinfo(listp);
    
    exit(0);
}
```

##### 동작 설명

1. `hints` 구조체를 초기화하여 원하는 주소 반환하도록 설정
2. 32비트 IP 주소 (IPv4) 검색
3. 연결 끝점으로 사용 가능한 소켓 주소만 검색
4. `NI_NUMERICHOST` 플래그로 도메인 이름 대신 점-십진 문자열 출력

##### 실행 결과
```bash
linux> ./hostinfo twitter.com
199.16.156.102
199.16.156.230
199.16.156.6
199.16.156.70
```

Section 11.3.2의 `nslookup`과 동일한 결과!

---

### CSAPP 11.4.8

`getaddrinfo` 함수와 소켓 인터페이스는 처음 배울 때 다소 어렵게 느껴질 수 있다. 

클라이언트와 서버가 서로 통신할 때 사용할 수 있는 더 높은 수준의 헬퍼 함수로 래핑하면 편리하다: `open_clientfd`와 `open_listenfd`.

#### The open_clientfd Function

##### 함수 시그니처
```c
#include "csapp.h"

int open_clientfd(char *hostname, char *port);
// 반환: 성공 시 디스크립터, 오류 시 -1
```

##### 기능

- 클라이언트가 서버와의 연결을 설정하기 위해 호출
- 호스트 `hostname`에서 실행 중이고 포트 번호 `port`에서 연결 요청을 수신 대기 중인 서버와 연결 설립
- Unix I/O 함수를 사용하여 입출력 준비가 완료된 열린 소켓 디스크립터 반환

##### 구현

![](/assets/img/images/2025-11-02-4.png)


```c
int open_clientfd(char *hostname, char *port) {
    int clientfd;
    struct addrinfo hints, *listp, *p;
    
    /* addrinfo 구조체 리스트 획득 */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;  /* 연결 열기 */
    hints.ai_flags = AI_NUMERICSERV;  /* 숫자 포트 인자 사용 */
    hints.ai_flags |= AI_ADDRCONFIG;  /* 연결에 권장 */
    Getaddrinfo(hostname, port, &hints, &listp);
    
    /* 성공적으로 연결할 수 있는 것을 찾을 때까지 리스트 순회 */
    for (p = listp; p; p = p->ai_next) {
        /* 소켓 디스크립터 생성 */
        if ((clientfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
            continue; /* 소켓 실패, 다음 시도 */
        
        /* 서버에 연결 */
        if (connect(clientfd, p->ai_addr, p->ai_addrlen) != -1)
            break; /* 성공 */
        Close(clientfd); /* 연결 실패, 다른 것 시도 */
    }
    
    /* 정리 */
    Freeaddrinfo(listp);
    if (!p) /* 모든 연결 실패 */
        return -1;
    else    /* 마지막 연결 성공 */
        return clientfd;
}
```

##### 동작 방식

1. `getaddrinfo` 호출 → `addrinfo` 구조체 리스트 반환
2. 각 구조체는 연결 설정에 적합한 소켓 주소 구조체를 가리킴
3. 리스트를 순회하며 각 항목 시도
4. `socket`과 `connect`가 성공할 때까지 반복
5. `connect` 실패 시, 다음 항목 시도 전에 소켓 디스크립터 닫기 주의
6. `connect` 성공 시, 리스트 메모리 해제 후 소켓 디스크립터를 클라이언트에 반환
7. 클라이언트는 즉시 서버와 통신 시작 가능

##### 중요 특징

코드 어디에도 특정 IP 버전에 대한 의존성이 없음
- `socket`과 `connect`의 인자는 `getaddrinfo`가 자동으로 생성
- 코드가 깔끔하고 이식 가능(portable)

---

#### The open_listenfd Function

##### 함수 시그니처
```c
#include "csapp.h"

int open_listenfd(char *port);
// 반환: 성공 시 디스크립터, 오류 시 -1
```

##### 기능

- 포트 `port`에서 연결 요청을 수신할 준비가 된 수신 디스크립터 반환

#####

![](/assets/img/images/2025-11-02-5.png)


```c
int open_listenfd(char *port) {
    struct addrinfo hints, *listp, *p;
    int listenfd, optval=1;
    
    /* addrinfo 구조체 리스트 획득 */
    memset(&hints, 0, sizeof(struct addrinfo));
    hints.ai_socktype = SOCK_STREAM;              /* 연결 수락 */
    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;  /* 모든 IP 주소에서 */
    hints.ai_flags |= AI_NUMERICSERV;             /* 포트 번호 사용 */
    Getaddrinfo(NULL, port, &hints, &listp);
    
    /* 바인딩할 수 있는 것을 찾을 때까지 리스트 순회 */
    for (p = listp; p; p = p->ai_next) {
        /* 소켓 디스크립터 생성 */
        if ((listenfd = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) < 0)
            continue; /* 소켓 실패, 다음 시도 */
        
        /* "Address already in use" 에러 제거 */
        Setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR,
                   (const void *)&optval, sizeof(int));
        
        /* 디스크립터를 주소에 바인딩 */
        if (bind(listenfd, p->ai_addr, p->ai_addrlen) == 0)
            break; /* 성공 */
        Close(listenfd); /* 바인드 실패, 다음 시도 */
    }
    
    /* 정리 */
    Freeaddrinfo(listp);
    if (!p) /* 어떤 주소도 작동하지 않음 */
        return -1;
    
    /* 연결 요청을 수락할 준비가 된 수신 소켓으로 만들기 */
    if (listen(listenfd, LISTENQ) < 0) {
        Close(listenfd);
        return -1;
    }
    return listenfd;
}
```

##### 동작 방식

1. 스타일은 `open_clientfd`와 유사
2. `getaddrinfo` 호출 후 결과 리스트 순회
3. `socket`과 `bind`가 성공할 때까지 시도
4. `setsockopt` 함수 사용: 서버가 종료되고 재시작된 후 즉시 연결 요청 수락 가능하도록 구성
   - 기본적으로 재시작된 서버는 약 30초 동안 클라이언트의 연결 요청을 거부 (디버깅에 방해)
5. `AI_PASSIVE` 플래그와 NULL host 인자로 `getaddrinfo` 호출
   - 각 소켓 주소 구조체의 주소 필드가 와일드카드 주소로 설정됨
   - 커널에게 이 서버가 이 호스트의 모든 IP 주소로의 요청을 수락할 것임을 알림
6. `listen` 함수 호출하여 `listenfd`를 수신 디스크립터로 변환하고 호출자에게 반환
7. `listen` 실패 시, 반환 전에 디스크립터를 닫아 메모리 누수 방지

---

### CSAPP 11.4.9

소켓 인터페이스를 배우는 가장 좋은 방법은 예제 코드를 공부하는 것이다.

#### Echo Client

![](/assets/img/images/2025-11-02-6.png)

```c
#include "csapp.h"

int main(int argc, char **argv)
{
    int clientfd;
    char *host, *port, buf[MAXLINE];
    rio_t rio;
    
    if (argc != 3) {
        fprintf(stderr, "usage: %s <host> <port>\n", argv[0]);
        exit(0);
    }
    host = argv[1];
    port = argv[2];
    
    clientfd = Open_clientfd(host, port);
    Rio_readinitb(&rio, clientfd);
    
    while (Fgets(buf, MAXLINE, stdin) != NULL) {
        Rio_writen(clientfd, buf, strlen(buf));
        Rio_readlineb(&rio, buf, MAXLINE);
        Fputs(buf, stdout);
    }
    Close(clientfd);
    exit(0);
}
```

##### 동작 방식

1. 서버와 연결 설정
2. 루프 진입:
   - 표준 입력에서 텍스트 라인 반복적으로 읽기
   - 텍스트 라인을 서버에 전송
   - 서버로부터 에코 라인 읽기
   - 결과를 표준 출력에 출력
3. 루프 종료 조건:
   - `fgets`가 표준 입력에서 EOF 만남
   - 사용자가 키보드에서 Ctrl+D 입력
   - 리다이렉트된 입력 파일의 텍스트 라인이 소진됨
4. 루프 종료 후:
   - 클라이언트가 디스크립터 닫음
   - 서버에 EOF 알림 전송
   - 서버는 `rio_readlineb` 함수에서 반환 코드 0을 받아 감지
5. 디스크립터 닫은 후 클라이언트 종료

##### 프로그래밍 관행

- 라인 24의 `close`는 필수가 아님 (클라이언트의 커널이 프로세스 종료 시 모든 열린 디스크립터 자동 종료)
- 하지만 열었던 모든 디스크립터를 명시적으로 닫는 것이 좋은 프로그래밍 관행

---

#### Echo Server

![](/assets/img/images/2025-11-02-7.png)

```c
#include "csapp.h"

int main(int argc, char **argv)
{
    int listenfd, connfd;
    socklen_t clientlen;
    struct sockaddr_storage clientaddr; /* 모든 주소에 충분한 공간 */
    char client_hostname[MAXLINE], client_port[MAXLINE];
    
    if (argc != 2) {
        fprintf(stderr, "usage: %s <port>\n", argv[0]);
        exit(0);
    }
    
    listenfd = Open_listenfd(argv[1]);
    while (1) {
        clientlen = sizeof(struct sockaddr_storage);
        connfd = Accept(listenfd, (SA *)&clientaddr, &clientlen);
        Getnameinfo((SA *) &clientaddr, clientlen, 
                    client_hostname, MAXLINE,
                    client_port, MAXLINE, 0);
        printf("Connected to (%s, %s)\n", client_hostname, client_port);
        echo(connfd);
        Close(connfd);
    }
    exit(0);
}
```

##### 동작 방식

1. 수신 디스크립터 열기
2. 무한 루프 진입:
   - 클라이언트로부터의 연결 요청 대기
   - 연결된 클라이언트의 도메인 이름과 포트 출력
   - 클라이언트에게 서비스하는 `echo` 함수 호출
3. `echo` 루틴 반환 후:
   - 메인 루틴이 연결 디스크립터 닫음
   - 클라이언트와 서버가 각자의 디스크립터를 닫으면 연결 종료

##### clientaddr 변수 (라인 9)

- `accept`에 전달되는 소켓 주소 구조체
- `accept`가 반환되기 전에 연결 반대편 클라이언트의 소켓 주소로 채워짐
- `struct sockaddr_storage` 타입으로 선언 (not `struct sockaddr_in`)
- 이유: `sockaddr_storage` 구조체는 모든 유형의 소켓 주소를 저장할 수 있을 만큼 충분히 큼
- 코드를 프로토콜 독립적으로 유지

##### 서버 유형

- 이 간단한 에코 서버는 한 번에 한 클라이언트만 처리 가능
- 이렇게 클라이언트를 하나씩 반복 처리하는 서버를 **반복 서버(iterative server)**라고 함
- Chapter 12에서 여러 클라이언트를 동시에 처리할 수 있는 더 정교한 **동시 서버(concurrent server)** 구축 방법 학습

---

#### echo 함수

![](/assets/img/images/2025-11-02-8.png)

```c
#include "csapp.h"

void echo(int connfd)
{
    size_t n;
    char buf[MAXLINE];
    rio_t rio;
    
    Rio_readinitb(&rio, connfd);
    while((n = Rio_readlineb(&rio, buf, MAXLINE)) != 0) {
        printf("server received %d bytes\n", (int)n);
        Rio_writen(connfd, buf, n);
    }
}
```

##### 기능

- 텍스트 라인을 반복적으로 읽고 쓰기
- `rio_readlineb` 함수가 라인 10에서 EOF를 만날 때까지 계속

---

## 핵심 정리

### 11.4.7의 핵심
1. **getaddrinfo**: 문자열 → 소켓 주소 구조체 (프로토콜 독립적)
2. **getnameinfo**: 소켓 주소 구조체 → 문자열 (역변환)
3. **재진입 가능**: 멀티스레드 환경에서 안전
4. **프로토콜 독립적**: IP 버전에 무관하게 동작

### 11.4.8의 핵심
1. **open_clientfd**: 클라이언트용 헬퍼 함수 (연결 설정)
2. **open_listenfd**: 서버용 헬퍼 함수 (수신 소켓 생성)
3. **높은 추상화**: getaddrinfo와 소켓 함수들을 래핑
4. **프로토콜 독립적**: IP 버전에 독립적인 코드

### 11.4.9의 핵심
1. **Echo Client**: 표준 입력 → 서버 → 표준 출력
2. **Echo Server**: 클라이언트의 메시지를 그대로 반환
3. **반복 서버**: 한 번에 한 클라이언트만 처리
4. **실전 예제**: 소켓 프로그래밍의 완전한 작동 예시

## 코드 / 실습
```c
//오늘은 코드를 작성하지 않았다.
```